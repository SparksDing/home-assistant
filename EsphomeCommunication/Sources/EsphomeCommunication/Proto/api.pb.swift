// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum EntityCategory: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case config // = 1
  case diagnostic // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .config
    case 2: self = .diagnostic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .config: return 1
    case .diagnostic: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [EntityCategory] = [
    .none,
    .config,
    .diagnostic,
  ]

}

enum LegacyCoverState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case `open` // = 0
  case closed // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .open
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .open
    case 1: self = .closed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .open: return 0
    case .closed: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [LegacyCoverState] = [
    .open,
    .closed,
  ]

}

enum CoverOperation: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case idle // = 0
  case isOpening // = 1
  case isClosing // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .idle
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .idle
    case 1: self = .isOpening
    case 2: self = .isClosing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .idle: return 0
    case .isOpening: return 1
    case .isClosing: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [CoverOperation] = [
    .idle,
    .isOpening,
    .isClosing,
  ]

}

enum LegacyCoverCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case `open` // = 0
  case close // = 1
  case stop // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .open
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .open
    case 1: self = .close
    case 2: self = .stop
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .open: return 0
    case .close: return 1
    case .stop: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [LegacyCoverCommand] = [
    .open,
    .close,
    .stop,
  ]

}

enum FanSpeed: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case low // = 0
  case medium // = 1
  case high // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .low
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .low
    case 1: self = .medium
    case 2: self = .high
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .low: return 0
    case .medium: return 1
    case .high: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [FanSpeed] = [
    .low,
    .medium,
    .high,
  ]

}

enum FanDirection: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case forward // = 0
  case reverse // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .forward
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .forward
    case 1: self = .reverse
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .forward: return 0
    case .reverse: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [FanDirection] = [
    .forward,
    .reverse,
  ]

}

/// ==================== LIGHT ====================
enum ColorMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case onOff // = 1
  case legacyBrightness // = 2
  case brightness // = 3
  case white // = 7
  case colorTemperature // = 11
  case coldWarmWhite // = 19
  case rgb // = 35
  case rgbWhite // = 39
  case rgbColorTemperature // = 47
  case rgbColdWarmWhite // = 51
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .onOff
    case 2: self = .legacyBrightness
    case 3: self = .brightness
    case 7: self = .white
    case 11: self = .colorTemperature
    case 19: self = .coldWarmWhite
    case 35: self = .rgb
    case 39: self = .rgbWhite
    case 47: self = .rgbColorTemperature
    case 51: self = .rgbColdWarmWhite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .onOff: return 1
    case .legacyBrightness: return 2
    case .brightness: return 3
    case .white: return 7
    case .colorTemperature: return 11
    case .coldWarmWhite: return 19
    case .rgb: return 35
    case .rgbWhite: return 39
    case .rgbColorTemperature: return 47
    case .rgbColdWarmWhite: return 51
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ColorMode] = [
    .unknown,
    .onOff,
    .legacyBrightness,
    .brightness,
    .white,
    .colorTemperature,
    .coldWarmWhite,
    .rgb,
    .rgbWhite,
    .rgbColorTemperature,
    .rgbColdWarmWhite,
  ]

}

/// ==================== SENSOR ====================
enum SensorStateClass: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case stateClassNone // = 0
  case stateClassMeasurement // = 1
  case stateClassTotalIncreasing // = 2
  case stateClassTotal // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .stateClassNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stateClassNone
    case 1: self = .stateClassMeasurement
    case 2: self = .stateClassTotalIncreasing
    case 3: self = .stateClassTotal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .stateClassNone: return 0
    case .stateClassMeasurement: return 1
    case .stateClassTotalIncreasing: return 2
    case .stateClassTotal: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SensorStateClass] = [
    .stateClassNone,
    .stateClassMeasurement,
    .stateClassTotalIncreasing,
    .stateClassTotal,
  ]

}

enum SensorLastResetType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case lastResetNone // = 0
  case lastResetNever // = 1
  case lastResetAuto // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .lastResetNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .lastResetNone
    case 1: self = .lastResetNever
    case 2: self = .lastResetAuto
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .lastResetNone: return 0
    case .lastResetNever: return 1
    case .lastResetAuto: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [SensorLastResetType] = [
    .lastResetNone,
    .lastResetNever,
    .lastResetAuto,
  ]

}

/// ==================== SUBSCRIBE LOGS ====================
enum LogLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case error // = 1
  case warn // = 2
  case info // = 3
  case config // = 4
  case debug // = 5
  case verbose // = 6
  case veryVerbose // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .error
    case 2: self = .warn
    case 3: self = .info
    case 4: self = .config
    case 5: self = .debug
    case 6: self = .verbose
    case 7: self = .veryVerbose
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .error: return 1
    case .warn: return 2
    case .info: return 3
    case .config: return 4
    case .debug: return 5
    case .verbose: return 6
    case .veryVerbose: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [LogLevel] = [
    .none,
    .error,
    .warn,
    .info,
    .config,
    .debug,
    .verbose,
    .veryVerbose,
  ]

}

/// ==================== USER-DEFINES SERVICES ====================
enum ServiceArgType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case bool // = 0
  case int // = 1
  case float // = 2
  case string // = 3
  case boolArray // = 4
  case intArray // = 5
  case floatArray // = 6
  case stringArray // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .bool
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bool
    case 1: self = .int
    case 2: self = .float
    case 3: self = .string
    case 4: self = .boolArray
    case 5: self = .intArray
    case 6: self = .floatArray
    case 7: self = .stringArray
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .bool: return 0
    case .int: return 1
    case .float: return 2
    case .string: return 3
    case .boolArray: return 4
    case .intArray: return 5
    case .floatArray: return 6
    case .stringArray: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ServiceArgType] = [
    .bool,
    .int,
    .float,
    .string,
    .boolArray,
    .intArray,
    .floatArray,
    .stringArray,
  ]

}

/// ==================== CLIMATE ====================
enum ClimateMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case off // = 0
  case heatCool // = 1
  case cool // = 2
  case heat // = 3
  case fanOnly // = 4
  case dry // = 5
  case auto // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .off
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .off
    case 1: self = .heatCool
    case 2: self = .cool
    case 3: self = .heat
    case 4: self = .fanOnly
    case 5: self = .dry
    case 6: self = .auto
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .off: return 0
    case .heatCool: return 1
    case .cool: return 2
    case .heat: return 3
    case .fanOnly: return 4
    case .dry: return 5
    case .auto: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ClimateMode] = [
    .off,
    .heatCool,
    .cool,
    .heat,
    .fanOnly,
    .dry,
    .auto,
  ]

}

enum ClimateFanMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case climateFanOn // = 0
  case climateFanOff // = 1
  case climateFanAuto // = 2
  case climateFanLow // = 3
  case climateFanMedium // = 4
  case climateFanHigh // = 5
  case climateFanMiddle // = 6
  case climateFanFocus // = 7
  case climateFanDiffuse // = 8
  case climateFanQuiet // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .climateFanOn
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .climateFanOn
    case 1: self = .climateFanOff
    case 2: self = .climateFanAuto
    case 3: self = .climateFanLow
    case 4: self = .climateFanMedium
    case 5: self = .climateFanHigh
    case 6: self = .climateFanMiddle
    case 7: self = .climateFanFocus
    case 8: self = .climateFanDiffuse
    case 9: self = .climateFanQuiet
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .climateFanOn: return 0
    case .climateFanOff: return 1
    case .climateFanAuto: return 2
    case .climateFanLow: return 3
    case .climateFanMedium: return 4
    case .climateFanHigh: return 5
    case .climateFanMiddle: return 6
    case .climateFanFocus: return 7
    case .climateFanDiffuse: return 8
    case .climateFanQuiet: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ClimateFanMode] = [
    .climateFanOn,
    .climateFanOff,
    .climateFanAuto,
    .climateFanLow,
    .climateFanMedium,
    .climateFanHigh,
    .climateFanMiddle,
    .climateFanFocus,
    .climateFanDiffuse,
    .climateFanQuiet,
  ]

}

enum ClimateSwingMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case climateSwingOff // = 0
  case climateSwingBoth // = 1
  case climateSwingVertical // = 2
  case climateSwingHorizontal // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .climateSwingOff
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .climateSwingOff
    case 1: self = .climateSwingBoth
    case 2: self = .climateSwingVertical
    case 3: self = .climateSwingHorizontal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .climateSwingOff: return 0
    case .climateSwingBoth: return 1
    case .climateSwingVertical: return 2
    case .climateSwingHorizontal: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ClimateSwingMode] = [
    .climateSwingOff,
    .climateSwingBoth,
    .climateSwingVertical,
    .climateSwingHorizontal,
  ]

}

enum ClimateAction: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case off // = 0

  /// values same as mode for readability
  case cooling // = 2
  case heating // = 3
  case idle // = 4
  case drying // = 5
  case fan // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .off
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .off
    case 2: self = .cooling
    case 3: self = .heating
    case 4: self = .idle
    case 5: self = .drying
    case 6: self = .fan
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .off: return 0
    case .cooling: return 2
    case .heating: return 3
    case .idle: return 4
    case .drying: return 5
    case .fan: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ClimateAction] = [
    .off,
    .cooling,
    .heating,
    .idle,
    .drying,
    .fan,
  ]

}

enum ClimatePreset: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case home // = 1
  case away // = 2
  case boost // = 3
  case comfort // = 4
  case eco // = 5
  case sleep // = 6
  case activity // = 7
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .home
    case 2: self = .away
    case 3: self = .boost
    case 4: self = .comfort
    case 5: self = .eco
    case 6: self = .sleep
    case 7: self = .activity
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .home: return 1
    case .away: return 2
    case .boost: return 3
    case .comfort: return 4
    case .eco: return 5
    case .sleep: return 6
    case .activity: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ClimatePreset] = [
    .none,
    .home,
    .away,
    .boost,
    .comfort,
    .eco,
    .sleep,
    .activity,
  ]

}

/// ==================== NUMBER ====================
enum NumberMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case auto // = 0
  case box // = 1
  case slider // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .auto
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .auto
    case 1: self = .box
    case 2: self = .slider
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .auto: return 0
    case .box: return 1
    case .slider: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [NumberMode] = [
    .auto,
    .box,
    .slider,
  ]

}

/// ==================== LOCK ====================
enum LockState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case locked // = 1
  case unlocked // = 2
  case jammed // = 3
  case locking // = 4
  case unlocking // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .locked
    case 2: self = .unlocked
    case 3: self = .jammed
    case 4: self = .locking
    case 5: self = .unlocking
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .locked: return 1
    case .unlocked: return 2
    case .jammed: return 3
    case .locking: return 4
    case .unlocking: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [LockState] = [
    .none,
    .locked,
    .unlocked,
    .jammed,
    .locking,
    .unlocking,
  ]

}

enum LockCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case lockUnlock // = 0
  case lockLock // = 1
  case lockOpen // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .lockUnlock
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .lockUnlock
    case 1: self = .lockLock
    case 2: self = .lockOpen
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .lockUnlock: return 0
    case .lockLock: return 1
    case .lockOpen: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [LockCommand] = [
    .lockUnlock,
    .lockLock,
    .lockOpen,
  ]

}

/// ==================== MEDIA PLAYER ====================
enum MediaPlayerState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case idle // = 1
  case playing // = 2
  case paused // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .idle
    case 2: self = .playing
    case 3: self = .paused
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .idle: return 1
    case .playing: return 2
    case .paused: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [MediaPlayerState] = [
    .none,
    .idle,
    .playing,
    .paused,
  ]

}

enum MediaPlayerCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case play // = 0
  case pause // = 1
  case stop // = 2
  case mute // = 3
  case unmute // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .play
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .play
    case 1: self = .pause
    case 2: self = .stop
    case 3: self = .mute
    case 4: self = .unmute
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .play: return 0
    case .pause: return 1
    case .stop: return 2
    case .mute: return 3
    case .unmute: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [MediaPlayerCommand] = [
    .play,
    .pause,
    .stop,
    .mute,
    .unmute,
  ]

}

enum MediaPlayerFormatPurpose: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case `default` // = 0
  case announcement // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .default
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .announcement
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .default: return 0
    case .announcement: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [MediaPlayerFormatPurpose] = [
    .default,
    .announcement,
  ]

}

enum BluetoothDeviceRequestType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case connect // = 0
  case disconnect // = 1
  case pair // = 2
  case unpair // = 3
  case connectV3WithCache // = 4
  case connectV3WithoutCache // = 5
  case clearCache // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .connect
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .connect
    case 1: self = .disconnect
    case 2: self = .pair
    case 3: self = .unpair
    case 4: self = .connectV3WithCache
    case 5: self = .connectV3WithoutCache
    case 6: self = .clearCache
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .connect: return 0
    case .disconnect: return 1
    case .pair: return 2
    case .unpair: return 3
    case .connectV3WithCache: return 4
    case .connectV3WithoutCache: return 5
    case .clearCache: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [BluetoothDeviceRequestType] = [
    .connect,
    .disconnect,
    .pair,
    .unpair,
    .connectV3WithCache,
    .connectV3WithoutCache,
    .clearCache,
  ]

}

enum BluetoothScannerState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case idle // = 0
  case starting // = 1
  case running // = 2
  case failed // = 3
  case stopping // = 4
  case stopped // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .idle
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .idle
    case 1: self = .starting
    case 2: self = .running
    case 3: self = .failed
    case 4: self = .stopping
    case 5: self = .stopped
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .idle: return 0
    case .starting: return 1
    case .running: return 2
    case .failed: return 3
    case .stopping: return 4
    case .stopped: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [BluetoothScannerState] = [
    .idle,
    .starting,
    .running,
    .failed,
    .stopping,
    .stopped,
  ]

}

enum BluetoothScannerMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case passive // = 0
  case active // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .passive
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .passive
    case 1: self = .active
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .passive: return 0
    case .active: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [BluetoothScannerMode] = [
    .passive,
    .active,
  ]

}

/// ==================== VOICE ASSISTANT ====================
enum VoiceAssistantSubscribeFlag: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case voiceAssistantSubscribeNone // = 0
  case voiceAssistantSubscribeApiAudio // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .voiceAssistantSubscribeNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .voiceAssistantSubscribeNone
    case 1: self = .voiceAssistantSubscribeApiAudio
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .voiceAssistantSubscribeNone: return 0
    case .voiceAssistantSubscribeApiAudio: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VoiceAssistantSubscribeFlag] = [
    .voiceAssistantSubscribeNone,
    .voiceAssistantSubscribeApiAudio,
  ]

}

enum VoiceAssistantRequestFlag: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case voiceAssistantRequestNone // = 0
  case voiceAssistantRequestUseVad // = 1
  case voiceAssistantRequestUseWakeWord // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .voiceAssistantRequestNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .voiceAssistantRequestNone
    case 1: self = .voiceAssistantRequestUseVad
    case 2: self = .voiceAssistantRequestUseWakeWord
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .voiceAssistantRequestNone: return 0
    case .voiceAssistantRequestUseVad: return 1
    case .voiceAssistantRequestUseWakeWord: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VoiceAssistantRequestFlag] = [
    .voiceAssistantRequestNone,
    .voiceAssistantRequestUseVad,
    .voiceAssistantRequestUseWakeWord,
  ]

}

enum VoiceAssistantEvent: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case voiceAssistantError // = 0
  case voiceAssistantRunStart // = 1
  case voiceAssistantRunEnd // = 2
  case voiceAssistantSttStart // = 3
  case voiceAssistantSttEnd // = 4
  case voiceAssistantIntentStart // = 5
  case voiceAssistantIntentEnd // = 6
  case voiceAssistantTtsStart // = 7
  case voiceAssistantTtsEnd // = 8
  case voiceAssistantWakeWordStart // = 9
  case voiceAssistantWakeWordEnd // = 10
  case voiceAssistantSttVadStart // = 11
  case voiceAssistantSttVadEnd // = 12
  case voiceAssistantTtsStreamStart // = 98
  case voiceAssistantTtsStreamEnd // = 99
  case UNRECOGNIZED(Int)

  init() {
    self = .voiceAssistantError
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .voiceAssistantError
    case 1: self = .voiceAssistantRunStart
    case 2: self = .voiceAssistantRunEnd
    case 3: self = .voiceAssistantSttStart
    case 4: self = .voiceAssistantSttEnd
    case 5: self = .voiceAssistantIntentStart
    case 6: self = .voiceAssistantIntentEnd
    case 7: self = .voiceAssistantTtsStart
    case 8: self = .voiceAssistantTtsEnd
    case 9: self = .voiceAssistantWakeWordStart
    case 10: self = .voiceAssistantWakeWordEnd
    case 11: self = .voiceAssistantSttVadStart
    case 12: self = .voiceAssistantSttVadEnd
    case 98: self = .voiceAssistantTtsStreamStart
    case 99: self = .voiceAssistantTtsStreamEnd
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .voiceAssistantError: return 0
    case .voiceAssistantRunStart: return 1
    case .voiceAssistantRunEnd: return 2
    case .voiceAssistantSttStart: return 3
    case .voiceAssistantSttEnd: return 4
    case .voiceAssistantIntentStart: return 5
    case .voiceAssistantIntentEnd: return 6
    case .voiceAssistantTtsStart: return 7
    case .voiceAssistantTtsEnd: return 8
    case .voiceAssistantWakeWordStart: return 9
    case .voiceAssistantWakeWordEnd: return 10
    case .voiceAssistantSttVadStart: return 11
    case .voiceAssistantSttVadEnd: return 12
    case .voiceAssistantTtsStreamStart: return 98
    case .voiceAssistantTtsStreamEnd: return 99
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VoiceAssistantEvent] = [
    .voiceAssistantError,
    .voiceAssistantRunStart,
    .voiceAssistantRunEnd,
    .voiceAssistantSttStart,
    .voiceAssistantSttEnd,
    .voiceAssistantIntentStart,
    .voiceAssistantIntentEnd,
    .voiceAssistantTtsStart,
    .voiceAssistantTtsEnd,
    .voiceAssistantWakeWordStart,
    .voiceAssistantWakeWordEnd,
    .voiceAssistantSttVadStart,
    .voiceAssistantSttVadEnd,
    .voiceAssistantTtsStreamStart,
    .voiceAssistantTtsStreamEnd,
  ]

}

enum VoiceAssistantTimerEvent: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case voiceAssistantTimerStarted // = 0
  case voiceAssistantTimerUpdated // = 1
  case voiceAssistantTimerCancelled // = 2
  case voiceAssistantTimerFinished // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .voiceAssistantTimerStarted
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .voiceAssistantTimerStarted
    case 1: self = .voiceAssistantTimerUpdated
    case 2: self = .voiceAssistantTimerCancelled
    case 3: self = .voiceAssistantTimerFinished
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .voiceAssistantTimerStarted: return 0
    case .voiceAssistantTimerUpdated: return 1
    case .voiceAssistantTimerCancelled: return 2
    case .voiceAssistantTimerFinished: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [VoiceAssistantTimerEvent] = [
    .voiceAssistantTimerStarted,
    .voiceAssistantTimerUpdated,
    .voiceAssistantTimerCancelled,
    .voiceAssistantTimerFinished,
  ]

}

/// ==================== ALARM CONTROL PANEL ====================
enum AlarmControlPanelState: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case alarmStateDisarmed // = 0
  case alarmStateArmedHome // = 1
  case alarmStateArmedAway // = 2
  case alarmStateArmedNight // = 3
  case alarmStateArmedVacation // = 4
  case alarmStateArmedCustomBypass // = 5
  case alarmStatePending // = 6
  case alarmStateArming // = 7
  case alarmStateDisarming // = 8
  case alarmStateTriggered // = 9
  case UNRECOGNIZED(Int)

  init() {
    self = .alarmStateDisarmed
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .alarmStateDisarmed
    case 1: self = .alarmStateArmedHome
    case 2: self = .alarmStateArmedAway
    case 3: self = .alarmStateArmedNight
    case 4: self = .alarmStateArmedVacation
    case 5: self = .alarmStateArmedCustomBypass
    case 6: self = .alarmStatePending
    case 7: self = .alarmStateArming
    case 8: self = .alarmStateDisarming
    case 9: self = .alarmStateTriggered
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .alarmStateDisarmed: return 0
    case .alarmStateArmedHome: return 1
    case .alarmStateArmedAway: return 2
    case .alarmStateArmedNight: return 3
    case .alarmStateArmedVacation: return 4
    case .alarmStateArmedCustomBypass: return 5
    case .alarmStatePending: return 6
    case .alarmStateArming: return 7
    case .alarmStateDisarming: return 8
    case .alarmStateTriggered: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AlarmControlPanelState] = [
    .alarmStateDisarmed,
    .alarmStateArmedHome,
    .alarmStateArmedAway,
    .alarmStateArmedNight,
    .alarmStateArmedVacation,
    .alarmStateArmedCustomBypass,
    .alarmStatePending,
    .alarmStateArming,
    .alarmStateDisarming,
    .alarmStateTriggered,
  ]

}

enum AlarmControlPanelStateCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case alarmControlPanelDisarm // = 0
  case alarmControlPanelArmAway // = 1
  case alarmControlPanelArmHome // = 2
  case alarmControlPanelArmNight // = 3
  case alarmControlPanelArmVacation // = 4
  case alarmControlPanelArmCustomBypass // = 5
  case alarmControlPanelTrigger // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .alarmControlPanelDisarm
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .alarmControlPanelDisarm
    case 1: self = .alarmControlPanelArmAway
    case 2: self = .alarmControlPanelArmHome
    case 3: self = .alarmControlPanelArmNight
    case 4: self = .alarmControlPanelArmVacation
    case 5: self = .alarmControlPanelArmCustomBypass
    case 6: self = .alarmControlPanelTrigger
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .alarmControlPanelDisarm: return 0
    case .alarmControlPanelArmAway: return 1
    case .alarmControlPanelArmHome: return 2
    case .alarmControlPanelArmNight: return 3
    case .alarmControlPanelArmVacation: return 4
    case .alarmControlPanelArmCustomBypass: return 5
    case .alarmControlPanelTrigger: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AlarmControlPanelStateCommand] = [
    .alarmControlPanelDisarm,
    .alarmControlPanelArmAway,
    .alarmControlPanelArmHome,
    .alarmControlPanelArmNight,
    .alarmControlPanelArmVacation,
    .alarmControlPanelArmCustomBypass,
    .alarmControlPanelTrigger,
  ]

}

/// ===================== TEXT =====================
enum TextMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case text // = 0
  case password // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .text
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .text
    case 1: self = .password
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .text: return 0
    case .password: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [TextMode] = [
    .text,
    .password,
  ]

}

enum ValveOperation: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case idle // = 0
  case isOpening // = 1
  case isClosing // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .idle
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .idle
    case 1: self = .isOpening
    case 2: self = .isClosing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .idle: return 0
    case .isOpening: return 1
    case .isClosing: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [ValveOperation] = [
    .idle,
    .isOpening,
    .isClosing,
  ]

}

enum UpdateCommand: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case none // = 0
  case update // = 1
  case check // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .update
    case 2: self = .check
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .update: return 1
    case .check: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [UpdateCommand] = [
    .none,
    .update,
    .check,
  ]

}

/// Message sent at the beginning of each connection
/// Can only be sent by the client and only at the beginning of the connection
struct HelloRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Description of client (like User Agent)
  /// For example "Home Assistant"
  /// Not strictly necessary to send but nice for debugging
  /// purposes.
  var clientInfo: String = String()

  var apiVersionMajor: UInt32 = 0

  var apiVersionMinor: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of successful connection request.
/// Can only be sent by the server and only at the beginning of the connection
struct HelloResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the API to use. The _client_ (for example Home Assistant) needs to check
  /// for compatibility and if necessary adopt to an older API.
  /// Major is for breaking changes in the base protocol - a mismatch will lead to immediate disconnect_client_
  /// Minor is for breaking changes in individual messages - a mismatch will lead to a warning message
  var apiVersionMajor: UInt32 = 0

  var apiVersionMinor: UInt32 = 0

  /// A string identifying the server (ESP); like client info this may be empty
  /// and only exists for debugging/logging purposes.
  /// For example "ESPHome v1.10.0 on ESP8266"
  var serverInfo: String = String()

  /// The name of the server (App.get_name())
  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Message sent at the beginning of each connection to authenticate the client
/// Can only be sent by the client and only at the beginning of the connection
struct ConnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The password to log in with
  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Confirmation of successful connection. After this the connection is available for all traffic.
/// Can only be sent by the server and only at the beginning of the connection
struct ConnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var invalidPassword: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request to close the connection.
/// Can be sent by both the client and server
struct DisconnectRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DisconnectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeviceInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeviceInfoResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var usesPassword: Bool {
    get {return _storage._usesPassword}
    set {_uniqueStorage()._usesPassword = newValue}
  }

  /// The name of the node, given by "App.set_name()"
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The mac address of the device. For example "AC:BC:32:89:0E:A9"
  var macAddress: String {
    get {return _storage._macAddress}
    set {_uniqueStorage()._macAddress = newValue}
  }

  /// A string describing the ESPHome version. For example "1.10.0"
  var esphomeVersion: String {
    get {return _storage._esphomeVersion}
    set {_uniqueStorage()._esphomeVersion = newValue}
  }

  /// A string describing the date of compilation, this is generated by the compiler
  /// and therefore may not be in the same format all the time.
  /// If the user isn't using ESPHome, this will also not be set.
  var compilationTime: String {
    get {return _storage._compilationTime}
    set {_uniqueStorage()._compilationTime = newValue}
  }

  /// The model of the board. For example NodeMCU
  var model: String {
    get {return _storage._model}
    set {_uniqueStorage()._model = newValue}
  }

  var hasDeepSleep_p: Bool {
    get {return _storage._hasDeepSleep_p}
    set {_uniqueStorage()._hasDeepSleep_p = newValue}
  }

  /// The esphome project details if set
  var projectName: String {
    get {return _storage._projectName}
    set {_uniqueStorage()._projectName = newValue}
  }

  var projectVersion: String {
    get {return _storage._projectVersion}
    set {_uniqueStorage()._projectVersion = newValue}
  }

  var webserverPort: UInt32 {
    get {return _storage._webserverPort}
    set {_uniqueStorage()._webserverPort = newValue}
  }

  var legacyBluetoothProxyVersion: UInt32 {
    get {return _storage._legacyBluetoothProxyVersion}
    set {_uniqueStorage()._legacyBluetoothProxyVersion = newValue}
  }

  var bluetoothProxyFeatureFlags: UInt32 {
    get {return _storage._bluetoothProxyFeatureFlags}
    set {_uniqueStorage()._bluetoothProxyFeatureFlags = newValue}
  }

  var manufacturer: String {
    get {return _storage._manufacturer}
    set {_uniqueStorage()._manufacturer = newValue}
  }

  var friendlyName: String {
    get {return _storage._friendlyName}
    set {_uniqueStorage()._friendlyName = newValue}
  }

  var legacyVoiceAssistantVersion: UInt32 {
    get {return _storage._legacyVoiceAssistantVersion}
    set {_uniqueStorage()._legacyVoiceAssistantVersion = newValue}
  }

  var voiceAssistantFeatureFlags: UInt32 {
    get {return _storage._voiceAssistantFeatureFlags}
    set {_uniqueStorage()._voiceAssistantFeatureFlags = newValue}
  }

  var suggestedArea: String {
    get {return _storage._suggestedArea}
    set {_uniqueStorage()._suggestedArea = newValue}
  }

  /// The Bluetooth mac address of the device. For example "AC:BC:32:89:0E:AA"
  var bluetoothMacAddress: String {
    get {return _storage._bluetoothMacAddress}
    set {_uniqueStorage()._bluetoothMacAddress = newValue}
  }

  /// Supports receiving and saving api encryption key
  var apiEncryptionSupported: Bool {
    get {return _storage._apiEncryptionSupported}
    set {_uniqueStorage()._apiEncryptionSupported = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ListEntitiesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListEntitiesDoneResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubscribeStatesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== BINARY SENSOR ====================
struct ListEntitiesBinarySensorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var deviceClass: String = String()

  var isStatusBinarySensor: Bool = false

  var disabledByDefault: Bool = false

  var icon: String = String()

  var entityCategory: EntityCategory = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BinarySensorStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: Bool = false

  /// If the binary sensor does not have a valid state yet.
  /// Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
  var missingState: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== COVER ====================
struct ListEntitiesCoverResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var assumedState: Bool = false

  var supportsPosition: Bool = false

  var supportsTilt: Bool = false

  var deviceClass: String = String()

  var disabledByDefault: Bool = false

  var icon: String = String()

  var entityCategory: EntityCategory = .none

  var supportsStop: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoverStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  /// legacy: state has been removed in 1.13
  /// clients/servers must still send/accept it until the next protocol change
  var legacyState: LegacyCoverState = .open

  var position: Float = 0

  var tilt: Float = 0

  var currentOperation: CoverOperation = .idle

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoverCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  /// legacy: command has been removed in 1.13
  /// clients/servers must still send/accept it until the next protocol change
  var hasLegacyCommand_p: Bool = false

  var legacyCommand: LegacyCoverCommand = .open

  var hasPosition_p: Bool = false

  var position: Float = 0

  var hasTilt_p: Bool = false

  var tilt: Float = 0

  var stop: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== FAN ====================
struct ListEntitiesFanResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var supportsOscillation: Bool = false

  var supportsSpeed: Bool = false

  var supportsDirection: Bool = false

  var supportedSpeedCount: Int32 = 0

  var disabledByDefault: Bool = false

  var icon: String = String()

  var entityCategory: EntityCategory = .none

  var supportedPresetModes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FanStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: Bool = false

  var oscillating: Bool = false

  /// NOTE: This field was marked as deprecated in the .proto file.
  var speed: FanSpeed = .low

  var direction: FanDirection = .forward

  var speedLevel: Int32 = 0

  var presetMode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FanCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var hasState_p: Bool = false

  var state: Bool = false

  /// NOTE: This field was marked as deprecated in the .proto file.
  var hasSpeed_p: Bool = false

  /// NOTE: This field was marked as deprecated in the .proto file.
  var speed: FanSpeed = .low

  var hasOscillating_p: Bool = false

  var oscillating: Bool = false

  var hasDirection_p: Bool = false

  var direction: FanDirection = .forward

  var hasSpeedLevel_p: Bool = false

  var speedLevel: Int32 = 0

  var hasPresetMode_p: Bool = false

  var presetMode: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListEntitiesLightResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var supportedColorModes: [ColorMode] = []

  /// next four supports_* are for legacy clients, newer clients should use color modes
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var legacySupportsBrightness: Bool = false

  /// NOTE: This field was marked as deprecated in the .proto file.
  var legacySupportsRgb: Bool = false

  /// NOTE: This field was marked as deprecated in the .proto file.
  var legacySupportsWhiteValue: Bool = false

  /// NOTE: This field was marked as deprecated in the .proto file.
  var legacySupportsColorTemperature: Bool = false

  var minMireds: Float = 0

  var maxMireds: Float = 0

  var effects: [String] = []

  var disabledByDefault: Bool = false

  var icon: String = String()

  var entityCategory: EntityCategory = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LightStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: Bool = false

  var brightness: Float = 0

  var colorMode: ColorMode = .unknown

  var colorBrightness: Float = 0

  var red: Float = 0

  var green: Float = 0

  var blue: Float = 0

  var white: Float = 0

  var colorTemperature: Float = 0

  var coldWhite: Float = 0

  var warmWhite: Float = 0

  var effect: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LightCommandRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  var hasState_p: Bool {
    get {return _storage._hasState_p}
    set {_uniqueStorage()._hasState_p = newValue}
  }

  var state: Bool {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var hasBrightness_p: Bool {
    get {return _storage._hasBrightness_p}
    set {_uniqueStorage()._hasBrightness_p = newValue}
  }

  var brightness: Float {
    get {return _storage._brightness}
    set {_uniqueStorage()._brightness = newValue}
  }

  var hasColorMode_p: Bool {
    get {return _storage._hasColorMode_p}
    set {_uniqueStorage()._hasColorMode_p = newValue}
  }

  var colorMode: ColorMode {
    get {return _storage._colorMode}
    set {_uniqueStorage()._colorMode = newValue}
  }

  var hasColorBrightness_p: Bool {
    get {return _storage._hasColorBrightness_p}
    set {_uniqueStorage()._hasColorBrightness_p = newValue}
  }

  var colorBrightness: Float {
    get {return _storage._colorBrightness}
    set {_uniqueStorage()._colorBrightness = newValue}
  }

  var hasRgb_p: Bool {
    get {return _storage._hasRgb_p}
    set {_uniqueStorage()._hasRgb_p = newValue}
  }

  var red: Float {
    get {return _storage._red}
    set {_uniqueStorage()._red = newValue}
  }

  var green: Float {
    get {return _storage._green}
    set {_uniqueStorage()._green = newValue}
  }

  var blue: Float {
    get {return _storage._blue}
    set {_uniqueStorage()._blue = newValue}
  }

  var hasWhite_p: Bool {
    get {return _storage._hasWhite_p}
    set {_uniqueStorage()._hasWhite_p = newValue}
  }

  var white: Float {
    get {return _storage._white}
    set {_uniqueStorage()._white = newValue}
  }

  var hasColorTemperature_p: Bool {
    get {return _storage._hasColorTemperature_p}
    set {_uniqueStorage()._hasColorTemperature_p = newValue}
  }

  var colorTemperature: Float {
    get {return _storage._colorTemperature}
    set {_uniqueStorage()._colorTemperature = newValue}
  }

  var hasColdWhite_p: Bool {
    get {return _storage._hasColdWhite_p}
    set {_uniqueStorage()._hasColdWhite_p = newValue}
  }

  var coldWhite: Float {
    get {return _storage._coldWhite}
    set {_uniqueStorage()._coldWhite = newValue}
  }

  var hasWarmWhite_p: Bool {
    get {return _storage._hasWarmWhite_p}
    set {_uniqueStorage()._hasWarmWhite_p = newValue}
  }

  var warmWhite: Float {
    get {return _storage._warmWhite}
    set {_uniqueStorage()._warmWhite = newValue}
  }

  var hasTransitionLength_p: Bool {
    get {return _storage._hasTransitionLength_p}
    set {_uniqueStorage()._hasTransitionLength_p = newValue}
  }

  var transitionLength: UInt32 {
    get {return _storage._transitionLength}
    set {_uniqueStorage()._transitionLength = newValue}
  }

  var hasFlashLength_p: Bool {
    get {return _storage._hasFlashLength_p}
    set {_uniqueStorage()._hasFlashLength_p = newValue}
  }

  var flashLength: UInt32 {
    get {return _storage._flashLength}
    set {_uniqueStorage()._flashLength = newValue}
  }

  var hasEffect_p: Bool {
    get {return _storage._hasEffect_p}
    set {_uniqueStorage()._hasEffect_p = newValue}
  }

  var effect: String {
    get {return _storage._effect}
    set {_uniqueStorage()._effect = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ListEntitiesSensorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var unitOfMeasurement: String = String()

  var accuracyDecimals: Int32 = 0

  var forceUpdate: Bool = false

  var deviceClass: String = String()

  var stateClass: SensorStateClass = .stateClassNone

  /// Last reset type removed in 2021.9.0
  var legacyLastResetType: SensorLastResetType = .lastResetNone

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SensorStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: Float = 0

  /// If the sensor does not have a valid state yet.
  /// Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
  var missingState: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== SWITCH ====================
struct ListEntitiesSwitchResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var assumedState: Bool = false

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var deviceClass: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SwitchStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SwitchCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== TEXT SENSOR ====================
struct ListEntitiesTextSensorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var deviceClass: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TextSensorStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: String = String()

  /// If the text sensor does not have a valid state yet.
  /// Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
  var missingState: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubscribeLogsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var level: LogLevel = .none

  var dumpConfig: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubscribeLogsResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var level: LogLevel = .none

  var message: Data = Data()

  var sendFailed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== NOISE ENCRYPTION ====================
struct NoiseEncryptionSetKeyRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct NoiseEncryptionSetKeyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== HOMEASSISTANT.SERVICE ====================
struct SubscribeHomeassistantServicesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HomeassistantServiceMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HomeassistantServiceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var service: String = String()

  var data: [HomeassistantServiceMap] = []

  var dataTemplate: [HomeassistantServiceMap] = []

  var variables: [HomeassistantServiceMap] = []

  var isEvent: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== IMPORT HOME ASSISTANT STATES ====================
/// 1. Client sends SubscribeHomeAssistantStatesRequest
/// 2. Server responds with zero or more SubscribeHomeAssistantStateResponse (async)
/// 3. Client sends HomeAssistantStateResponse for state changes.
struct SubscribeHomeAssistantStatesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubscribeHomeAssistantStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entityID: String = String()

  var attribute: String = String()

  var once: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HomeAssistantStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entityID: String = String()

  var state: String = String()

  var attribute: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== IMPORT TIME ====================
struct GetTimeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetTimeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochSeconds: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListEntitiesServicesArgument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var type: ServiceArgType = .bool

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListEntitiesServicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var key: UInt32 = 0

  var args: [ListEntitiesServicesArgument] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ExecuteServiceArgument: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bool_: Bool = false

  var legacyInt: Int32 = 0

  var float_: Float = 0

  var string_: String = String()

  /// ESPHome 1.14 (api v1.3) make int a signed value
  var int_: Int32 = 0

  var boolArray: [Bool] = []

  var intArray: [Int32] = []

  var floatArray: [Float] = []

  var stringArray: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ExecuteServiceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var args: [ExecuteServiceArgument] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== CAMERA ====================
struct ListEntitiesCameraResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var disabledByDefault: Bool = false

  var icon: String = String()

  var entityCategory: EntityCategory = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CameraImageResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var data: Data = Data()

  var done: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CameraImageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var single: Bool = false

  var stream: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListEntitiesClimateResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String {
    get {return _storage._objectID}
    set {_uniqueStorage()._objectID = newValue}
  }

  var key: UInt32 {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var uniqueID: String {
    get {return _storage._uniqueID}
    set {_uniqueStorage()._uniqueID = newValue}
  }

  var supportsCurrentTemperature: Bool {
    get {return _storage._supportsCurrentTemperature}
    set {_uniqueStorage()._supportsCurrentTemperature = newValue}
  }

  var supportsTwoPointTargetTemperature: Bool {
    get {return _storage._supportsTwoPointTargetTemperature}
    set {_uniqueStorage()._supportsTwoPointTargetTemperature = newValue}
  }

  var supportedModes: [ClimateMode] {
    get {return _storage._supportedModes}
    set {_uniqueStorage()._supportedModes = newValue}
  }

  var visualMinTemperature: Float {
    get {return _storage._visualMinTemperature}
    set {_uniqueStorage()._visualMinTemperature = newValue}
  }

  var visualMaxTemperature: Float {
    get {return _storage._visualMaxTemperature}
    set {_uniqueStorage()._visualMaxTemperature = newValue}
  }

  var visualTargetTemperatureStep: Float {
    get {return _storage._visualTargetTemperatureStep}
    set {_uniqueStorage()._visualTargetTemperatureStep = newValue}
  }

  /// for older peer versions - in new system this
  /// is if CLIMATE_PRESET_AWAY exists is supported_presets
  var legacySupportsAway: Bool {
    get {return _storage._legacySupportsAway}
    set {_uniqueStorage()._legacySupportsAway = newValue}
  }

  var supportsAction: Bool {
    get {return _storage._supportsAction}
    set {_uniqueStorage()._supportsAction = newValue}
  }

  var supportedFanModes: [ClimateFanMode] {
    get {return _storage._supportedFanModes}
    set {_uniqueStorage()._supportedFanModes = newValue}
  }

  var supportedSwingModes: [ClimateSwingMode] {
    get {return _storage._supportedSwingModes}
    set {_uniqueStorage()._supportedSwingModes = newValue}
  }

  var supportedCustomFanModes: [String] {
    get {return _storage._supportedCustomFanModes}
    set {_uniqueStorage()._supportedCustomFanModes = newValue}
  }

  var supportedPresets: [ClimatePreset] {
    get {return _storage._supportedPresets}
    set {_uniqueStorage()._supportedPresets = newValue}
  }

  var supportedCustomPresets: [String] {
    get {return _storage._supportedCustomPresets}
    set {_uniqueStorage()._supportedCustomPresets = newValue}
  }

  var disabledByDefault: Bool {
    get {return _storage._disabledByDefault}
    set {_uniqueStorage()._disabledByDefault = newValue}
  }

  var icon: String {
    get {return _storage._icon}
    set {_uniqueStorage()._icon = newValue}
  }

  var entityCategory: EntityCategory {
    get {return _storage._entityCategory}
    set {_uniqueStorage()._entityCategory = newValue}
  }

  var visualCurrentTemperatureStep: Float {
    get {return _storage._visualCurrentTemperatureStep}
    set {_uniqueStorage()._visualCurrentTemperatureStep = newValue}
  }

  var supportsCurrentHumidity: Bool {
    get {return _storage._supportsCurrentHumidity}
    set {_uniqueStorage()._supportsCurrentHumidity = newValue}
  }

  var supportsTargetHumidity: Bool {
    get {return _storage._supportsTargetHumidity}
    set {_uniqueStorage()._supportsTargetHumidity = newValue}
  }

  var visualMinHumidity: Float {
    get {return _storage._visualMinHumidity}
    set {_uniqueStorage()._visualMinHumidity = newValue}
  }

  var visualMaxHumidity: Float {
    get {return _storage._visualMaxHumidity}
    set {_uniqueStorage()._visualMaxHumidity = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ClimateStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var mode: ClimateMode = .off

  var currentTemperature: Float = 0

  var targetTemperature: Float = 0

  var targetTemperatureLow: Float = 0

  var targetTemperatureHigh: Float = 0

  /// For older peers, equal to preset == CLIMATE_PRESET_AWAY
  var unusedLegacyAway: Bool = false

  var action: ClimateAction = .off

  var fanMode: ClimateFanMode = .climateFanOn

  var swingMode: ClimateSwingMode = .climateSwingOff

  var customFanMode: String = String()

  var preset: ClimatePreset = .none

  var customPreset: String = String()

  var currentHumidity: Float = 0

  var targetHumidity: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ClimateCommandRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 {
    get {return _storage._key}
    set {_uniqueStorage()._key = newValue}
  }

  var hasMode_p: Bool {
    get {return _storage._hasMode_p}
    set {_uniqueStorage()._hasMode_p = newValue}
  }

  var mode: ClimateMode {
    get {return _storage._mode}
    set {_uniqueStorage()._mode = newValue}
  }

  var hasTargetTemperature_p: Bool {
    get {return _storage._hasTargetTemperature_p}
    set {_uniqueStorage()._hasTargetTemperature_p = newValue}
  }

  var targetTemperature: Float {
    get {return _storage._targetTemperature}
    set {_uniqueStorage()._targetTemperature = newValue}
  }

  var hasTargetTemperatureLow_p: Bool {
    get {return _storage._hasTargetTemperatureLow_p}
    set {_uniqueStorage()._hasTargetTemperatureLow_p = newValue}
  }

  var targetTemperatureLow: Float {
    get {return _storage._targetTemperatureLow}
    set {_uniqueStorage()._targetTemperatureLow = newValue}
  }

  var hasTargetTemperatureHigh_p: Bool {
    get {return _storage._hasTargetTemperatureHigh_p}
    set {_uniqueStorage()._hasTargetTemperatureHigh_p = newValue}
  }

  var targetTemperatureHigh: Float {
    get {return _storage._targetTemperatureHigh}
    set {_uniqueStorage()._targetTemperatureHigh = newValue}
  }

  /// legacy, for older peers, newer ones should use CLIMATE_PRESET_AWAY in preset
  var unusedHasLegacyAway: Bool {
    get {return _storage._unusedHasLegacyAway}
    set {_uniqueStorage()._unusedHasLegacyAway = newValue}
  }

  var unusedLegacyAway: Bool {
    get {return _storage._unusedLegacyAway}
    set {_uniqueStorage()._unusedLegacyAway = newValue}
  }

  var hasFanMode_p: Bool {
    get {return _storage._hasFanMode_p}
    set {_uniqueStorage()._hasFanMode_p = newValue}
  }

  var fanMode: ClimateFanMode {
    get {return _storage._fanMode}
    set {_uniqueStorage()._fanMode = newValue}
  }

  var hasSwingMode_p: Bool {
    get {return _storage._hasSwingMode_p}
    set {_uniqueStorage()._hasSwingMode_p = newValue}
  }

  var swingMode: ClimateSwingMode {
    get {return _storage._swingMode}
    set {_uniqueStorage()._swingMode = newValue}
  }

  var hasCustomFanMode_p: Bool {
    get {return _storage._hasCustomFanMode_p}
    set {_uniqueStorage()._hasCustomFanMode_p = newValue}
  }

  var customFanMode: String {
    get {return _storage._customFanMode}
    set {_uniqueStorage()._customFanMode = newValue}
  }

  var hasPreset_p: Bool {
    get {return _storage._hasPreset_p}
    set {_uniqueStorage()._hasPreset_p = newValue}
  }

  var preset: ClimatePreset {
    get {return _storage._preset}
    set {_uniqueStorage()._preset = newValue}
  }

  var hasCustomPreset_p: Bool {
    get {return _storage._hasCustomPreset_p}
    set {_uniqueStorage()._hasCustomPreset_p = newValue}
  }

  var customPreset: String {
    get {return _storage._customPreset}
    set {_uniqueStorage()._customPreset = newValue}
  }

  var hasTargetHumidity_p: Bool {
    get {return _storage._hasTargetHumidity_p}
    set {_uniqueStorage()._hasTargetHumidity_p = newValue}
  }

  var targetHumidity: Float {
    get {return _storage._targetHumidity}
    set {_uniqueStorage()._targetHumidity = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct ListEntitiesNumberResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var minValue: Float = 0

  var maxValue: Float = 0

  var step: Float = 0

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var unitOfMeasurement: String = String()

  var mode: NumberMode = .auto

  var deviceClass: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct NumberStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: Float = 0

  /// If the number does not have a valid state yet.
  /// Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
  var missingState: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct NumberCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== SELECT ====================
struct ListEntitiesSelectResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var options: [String] = []

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SelectStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: String = String()

  /// If the select does not have a valid state yet.
  /// Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
  var missingState: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SelectCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== SIREN ====================
struct ListEntitiesSirenResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var tones: [String] = []

  var supportsDuration: Bool = false

  var supportsVolume: Bool = false

  var entityCategory: EntityCategory = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SirenStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SirenCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var hasState_p: Bool = false

  var state: Bool = false

  var hasTone_p: Bool = false

  var tone: String = String()

  var hasDuration_p: Bool = false

  var duration: UInt32 = 0

  var hasVolume_p: Bool = false

  var volume: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListEntitiesLockResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var assumedState: Bool = false

  var supportsOpen: Bool = false

  var requiresCode: Bool = false

  /// Not yet implemented:
  var codeFormat: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LockStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: LockState = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LockCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var command: LockCommand = .lockUnlock

  /// Not yet implemented:
  var hasCode_p: Bool = false

  var code: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== BUTTON ====================
struct ListEntitiesButtonResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var deviceClass: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ButtonCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MediaPlayerSupportedFormat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var format: String = String()

  var sampleRate: UInt32 = 0

  var numChannels: UInt32 = 0

  var purpose: MediaPlayerFormatPurpose = .default

  var sampleBytes: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListEntitiesMediaPlayerResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var supportsPause: Bool = false

  var supportedFormats: [MediaPlayerSupportedFormat] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MediaPlayerStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: MediaPlayerState = .none

  var volume: Float = 0

  var muted: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MediaPlayerCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var hasCommand_p: Bool = false

  var command: MediaPlayerCommand = .play

  var hasVolume_p: Bool = false

  var volume: Float = 0

  var hasMediaURL_p: Bool = false

  var mediaURL: String = String()

  var hasAnnouncement_p: Bool = false

  var announcement: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== BLUETOOTH ====================
struct SubscribeBluetoothLEAdvertisementsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var flags: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothServiceData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  /// Removed in api version 1.7
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  var legacyData: [UInt32] = []

  /// Added in api version 1.7
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothLEAdvertisementResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var name: Data = Data()

  var rssi: Int32 = 0

  var serviceUuids: [String] = []

  var serviceData: [BluetoothServiceData] = []

  var manufacturerData: [BluetoothServiceData] = []

  var addressType: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothLERawAdvertisement: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var rssi: Int32 = 0

  var addressType: UInt32 = 0

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothLERawAdvertisementsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var advertisements: [BluetoothLERawAdvertisement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothDeviceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var requestType: BluetoothDeviceRequestType = .connect

  var hasAddressType_p: Bool = false

  var addressType: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothDeviceConnectionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var connected: Bool = false

  var mtu: UInt32 = 0

  var error: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTGetServicesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTDescriptor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: [UInt64] = []

  var handle: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTCharacteristic: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: [UInt64] = []

  var handle: UInt32 = 0

  var properties: UInt32 = 0

  var descriptors: [BluetoothGATTDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTService: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: [UInt64] = []

  var handle: UInt32 = 0

  var characteristics: [BluetoothGATTCharacteristic] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTGetServicesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var services: [BluetoothGATTService] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTGetServicesDoneResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTReadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var handle: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTReadResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var handle: UInt32 = 0

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTWriteRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var handle: UInt32 = 0

  var response: Bool = false

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTReadDescriptorRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var handle: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTWriteDescriptorRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var handle: UInt32 = 0

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTNotifyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var handle: UInt32 = 0

  var enable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTNotifyDataResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var handle: UInt32 = 0

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubscribeBluetoothConnectionsFreeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothConnectionsFreeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var free: UInt32 = 0

  var limit: UInt32 = 0

  var allocated: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTErrorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var handle: UInt32 = 0

  var error: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTWriteResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var handle: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothGATTNotifyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var handle: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothDevicePairingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var paired: Bool = false

  var error: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothDeviceUnpairingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var success: Bool = false

  var error: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UnsubscribeBluetoothLEAdvertisementsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothDeviceClearCacheResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: UInt64 = 0

  var success: Bool = false

  var error: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothScannerStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: BluetoothScannerState = .idle

  var mode: BluetoothScannerMode = .passive

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct BluetoothScannerSetModeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mode: BluetoothScannerMode = .passive

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubscribeVoiceAssistantRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscribe: Bool = false

  var flags: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantAudioSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var noiseSuppressionLevel: UInt32 = 0

  var autoGain: UInt32 = 0

  var volumeMultiplier: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: Bool = false

  var conversationID: String = String()

  var flags: UInt32 = 0

  var audioSettings: VoiceAssistantAudioSettings {
    get {return _audioSettings ?? VoiceAssistantAudioSettings()}
    set {_audioSettings = newValue}
  }
  /// Returns true if `audioSettings` has been explicitly set.
  var hasAudioSettings: Bool {return self._audioSettings != nil}
  /// Clears the value of `audioSettings`. Subsequent reads from it will return its default value.
  mutating func clearAudioSettings() {self._audioSettings = nil}

  var wakeWordPhrase: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _audioSettings: VoiceAssistantAudioSettings? = nil
}

struct VoiceAssistantResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var port: UInt32 = 0

  var error: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantEventData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventType: VoiceAssistantEvent = .voiceAssistantError

  var data: [VoiceAssistantEventData] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantAudio: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var end: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantTimerEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventType: VoiceAssistantTimerEvent = .voiceAssistantTimerStarted

  var timerID: String = String()

  var name: String = String()

  var totalSeconds: UInt32 = 0

  var secondsLeft: UInt32 = 0

  var isActive: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantAnnounceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mediaID: String = String()

  var text: String = String()

  var preannounceMediaID: String = String()

  var startConversation: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantAnnounceFinished: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantWakeWord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var wakeWord: String = String()

  var trainedLanguages: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantConfigurationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantConfigurationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var availableWakeWords: [VoiceAssistantWakeWord] = []

  var activeWakeWords: [String] = []

  var maxActiveWakeWords: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct VoiceAssistantSetConfiguration: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var activeWakeWords: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListEntitiesAlarmControlPanelResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var supportedFeatures: UInt32 = 0

  var requiresCode: Bool = false

  var requiresCodeToArm: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AlarmControlPanelStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: AlarmControlPanelState = .alarmStateDisarmed

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AlarmControlPanelCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var command: AlarmControlPanelStateCommand = .alarmControlPanelDisarm

  var code: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListEntitiesTextResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var minLength: UInt32 = 0

  var maxLength: UInt32 = 0

  var pattern: String = String()

  var mode: TextMode = .text

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TextStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: String = String()

  /// If the Text does not have a valid state yet.
  /// Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
  var missingState: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TextCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var state: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== DATETIME DATE ====================
struct ListEntitiesDateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DateStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  /// If the date does not have a valid state yet.
  /// Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
  var missingState: Bool = false

  var year: UInt32 = 0

  var month: UInt32 = 0

  var day: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DateCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var year: UInt32 = 0

  var month: UInt32 = 0

  var day: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== DATETIME TIME ====================
struct ListEntitiesTimeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TimeStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  /// If the time does not have a valid state yet.
  /// Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
  var missingState: Bool = false

  var hour: UInt32 = 0

  var minute: UInt32 = 0

  var second: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TimeCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var hour: UInt32 = 0

  var minute: UInt32 = 0

  var second: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== EVENT ====================
struct ListEntitiesEventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var deviceClass: String = String()

  var eventTypes: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct EventResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var eventType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== VALVE ====================
struct ListEntitiesValveResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var deviceClass: String = String()

  var assumedState: Bool = false

  var supportsPosition: Bool = false

  var supportsStop: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ValveStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var position: Float = 0

  var currentOperation: ValveOperation = .idle

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ValveCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var hasPosition_p: Bool = false

  var position: Float = 0

  var stop: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== DATETIME DATETIME ====================
struct ListEntitiesDateTimeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DateTimeStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  /// If the datetime does not have a valid state yet.
  /// Equivalent to `!obj->has_state()` - inverse logic to make state packets smaller
  var missingState: Bool = false

  var epochSeconds: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DateTimeCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var epochSeconds: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ==================== UPDATE ====================
struct ListEntitiesUpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var objectID: String = String()

  var key: UInt32 = 0

  var name: String = String()

  var uniqueID: String = String()

  var icon: String = String()

  var disabledByDefault: Bool = false

  var entityCategory: EntityCategory = .none

  var deviceClass: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UpdateStateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var missingState: Bool = false

  var inProgress: Bool = false

  var hasProgress_p: Bool = false

  var progress: Float = 0

  var currentVersion: String = String()

  var latestVersion: String = String()

  var title: String = String()

  var releaseSummary: String = String()

  var releaseURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UpdateCommandRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: UInt32 = 0

  var command: UpdateCommand = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension EntityCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENTITY_CATEGORY_NONE"),
    1: .same(proto: "ENTITY_CATEGORY_CONFIG"),
    2: .same(proto: "ENTITY_CATEGORY_DIAGNOSTIC"),
  ]
}

extension LegacyCoverState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEGACY_COVER_STATE_OPEN"),
    1: .same(proto: "LEGACY_COVER_STATE_CLOSED"),
  ]
}

extension CoverOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COVER_OPERATION_IDLE"),
    1: .same(proto: "COVER_OPERATION_IS_OPENING"),
    2: .same(proto: "COVER_OPERATION_IS_CLOSING"),
  ]
}

extension LegacyCoverCommand: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEGACY_COVER_COMMAND_OPEN"),
    1: .same(proto: "LEGACY_COVER_COMMAND_CLOSE"),
    2: .same(proto: "LEGACY_COVER_COMMAND_STOP"),
  ]
}

extension FanSpeed: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FAN_SPEED_LOW"),
    1: .same(proto: "FAN_SPEED_MEDIUM"),
    2: .same(proto: "FAN_SPEED_HIGH"),
  ]
}

extension FanDirection: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FAN_DIRECTION_FORWARD"),
    1: .same(proto: "FAN_DIRECTION_REVERSE"),
  ]
}

extension ColorMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COLOR_MODE_UNKNOWN"),
    1: .same(proto: "COLOR_MODE_ON_OFF"),
    2: .same(proto: "COLOR_MODE_LEGACY_BRIGHTNESS"),
    3: .same(proto: "COLOR_MODE_BRIGHTNESS"),
    7: .same(proto: "COLOR_MODE_WHITE"),
    11: .same(proto: "COLOR_MODE_COLOR_TEMPERATURE"),
    19: .same(proto: "COLOR_MODE_COLD_WARM_WHITE"),
    35: .same(proto: "COLOR_MODE_RGB"),
    39: .same(proto: "COLOR_MODE_RGB_WHITE"),
    47: .same(proto: "COLOR_MODE_RGB_COLOR_TEMPERATURE"),
    51: .same(proto: "COLOR_MODE_RGB_COLD_WARM_WHITE"),
  ]
}

extension SensorStateClass: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_CLASS_NONE"),
    1: .same(proto: "STATE_CLASS_MEASUREMENT"),
    2: .same(proto: "STATE_CLASS_TOTAL_INCREASING"),
    3: .same(proto: "STATE_CLASS_TOTAL"),
  ]
}

extension SensorLastResetType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LAST_RESET_NONE"),
    1: .same(proto: "LAST_RESET_NEVER"),
    2: .same(proto: "LAST_RESET_AUTO"),
  ]
}

extension LogLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOG_LEVEL_NONE"),
    1: .same(proto: "LOG_LEVEL_ERROR"),
    2: .same(proto: "LOG_LEVEL_WARN"),
    3: .same(proto: "LOG_LEVEL_INFO"),
    4: .same(proto: "LOG_LEVEL_CONFIG"),
    5: .same(proto: "LOG_LEVEL_DEBUG"),
    6: .same(proto: "LOG_LEVEL_VERBOSE"),
    7: .same(proto: "LOG_LEVEL_VERY_VERBOSE"),
  ]
}

extension ServiceArgType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SERVICE_ARG_TYPE_BOOL"),
    1: .same(proto: "SERVICE_ARG_TYPE_INT"),
    2: .same(proto: "SERVICE_ARG_TYPE_FLOAT"),
    3: .same(proto: "SERVICE_ARG_TYPE_STRING"),
    4: .same(proto: "SERVICE_ARG_TYPE_BOOL_ARRAY"),
    5: .same(proto: "SERVICE_ARG_TYPE_INT_ARRAY"),
    6: .same(proto: "SERVICE_ARG_TYPE_FLOAT_ARRAY"),
    7: .same(proto: "SERVICE_ARG_TYPE_STRING_ARRAY"),
  ]
}

extension ClimateMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIMATE_MODE_OFF"),
    1: .same(proto: "CLIMATE_MODE_HEAT_COOL"),
    2: .same(proto: "CLIMATE_MODE_COOL"),
    3: .same(proto: "CLIMATE_MODE_HEAT"),
    4: .same(proto: "CLIMATE_MODE_FAN_ONLY"),
    5: .same(proto: "CLIMATE_MODE_DRY"),
    6: .same(proto: "CLIMATE_MODE_AUTO"),
  ]
}

extension ClimateFanMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIMATE_FAN_ON"),
    1: .same(proto: "CLIMATE_FAN_OFF"),
    2: .same(proto: "CLIMATE_FAN_AUTO"),
    3: .same(proto: "CLIMATE_FAN_LOW"),
    4: .same(proto: "CLIMATE_FAN_MEDIUM"),
    5: .same(proto: "CLIMATE_FAN_HIGH"),
    6: .same(proto: "CLIMATE_FAN_MIDDLE"),
    7: .same(proto: "CLIMATE_FAN_FOCUS"),
    8: .same(proto: "CLIMATE_FAN_DIFFUSE"),
    9: .same(proto: "CLIMATE_FAN_QUIET"),
  ]
}

extension ClimateSwingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIMATE_SWING_OFF"),
    1: .same(proto: "CLIMATE_SWING_BOTH"),
    2: .same(proto: "CLIMATE_SWING_VERTICAL"),
    3: .same(proto: "CLIMATE_SWING_HORIZONTAL"),
  ]
}

extension ClimateAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIMATE_ACTION_OFF"),
    2: .same(proto: "CLIMATE_ACTION_COOLING"),
    3: .same(proto: "CLIMATE_ACTION_HEATING"),
    4: .same(proto: "CLIMATE_ACTION_IDLE"),
    5: .same(proto: "CLIMATE_ACTION_DRYING"),
    6: .same(proto: "CLIMATE_ACTION_FAN"),
  ]
}

extension ClimatePreset: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIMATE_PRESET_NONE"),
    1: .same(proto: "CLIMATE_PRESET_HOME"),
    2: .same(proto: "CLIMATE_PRESET_AWAY"),
    3: .same(proto: "CLIMATE_PRESET_BOOST"),
    4: .same(proto: "CLIMATE_PRESET_COMFORT"),
    5: .same(proto: "CLIMATE_PRESET_ECO"),
    6: .same(proto: "CLIMATE_PRESET_SLEEP"),
    7: .same(proto: "CLIMATE_PRESET_ACTIVITY"),
  ]
}

extension NumberMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NUMBER_MODE_AUTO"),
    1: .same(proto: "NUMBER_MODE_BOX"),
    2: .same(proto: "NUMBER_MODE_SLIDER"),
  ]
}

extension LockState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOCK_STATE_NONE"),
    1: .same(proto: "LOCK_STATE_LOCKED"),
    2: .same(proto: "LOCK_STATE_UNLOCKED"),
    3: .same(proto: "LOCK_STATE_JAMMED"),
    4: .same(proto: "LOCK_STATE_LOCKING"),
    5: .same(proto: "LOCK_STATE_UNLOCKING"),
  ]
}

extension LockCommand: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOCK_UNLOCK"),
    1: .same(proto: "LOCK_LOCK"),
    2: .same(proto: "LOCK_OPEN"),
  ]
}

extension MediaPlayerState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEDIA_PLAYER_STATE_NONE"),
    1: .same(proto: "MEDIA_PLAYER_STATE_IDLE"),
    2: .same(proto: "MEDIA_PLAYER_STATE_PLAYING"),
    3: .same(proto: "MEDIA_PLAYER_STATE_PAUSED"),
  ]
}

extension MediaPlayerCommand: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEDIA_PLAYER_COMMAND_PLAY"),
    1: .same(proto: "MEDIA_PLAYER_COMMAND_PAUSE"),
    2: .same(proto: "MEDIA_PLAYER_COMMAND_STOP"),
    3: .same(proto: "MEDIA_PLAYER_COMMAND_MUTE"),
    4: .same(proto: "MEDIA_PLAYER_COMMAND_UNMUTE"),
  ]
}

extension MediaPlayerFormatPurpose: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT"),
    1: .same(proto: "MEDIA_PLAYER_FORMAT_PURPOSE_ANNOUNCEMENT"),
  ]
}

extension BluetoothDeviceRequestType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT"),
    1: .same(proto: "BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT"),
    2: .same(proto: "BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR"),
    3: .same(proto: "BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR"),
    4: .same(proto: "BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE"),
    5: .same(proto: "BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE"),
    6: .same(proto: "BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE"),
  ]
}

extension BluetoothScannerState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLUETOOTH_SCANNER_STATE_IDLE"),
    1: .same(proto: "BLUETOOTH_SCANNER_STATE_STARTING"),
    2: .same(proto: "BLUETOOTH_SCANNER_STATE_RUNNING"),
    3: .same(proto: "BLUETOOTH_SCANNER_STATE_FAILED"),
    4: .same(proto: "BLUETOOTH_SCANNER_STATE_STOPPING"),
    5: .same(proto: "BLUETOOTH_SCANNER_STATE_STOPPED"),
  ]
}

extension BluetoothScannerMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BLUETOOTH_SCANNER_MODE_PASSIVE"),
    1: .same(proto: "BLUETOOTH_SCANNER_MODE_ACTIVE"),
  ]
}

extension VoiceAssistantSubscribeFlag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOICE_ASSISTANT_SUBSCRIBE_NONE"),
    1: .same(proto: "VOICE_ASSISTANT_SUBSCRIBE_API_AUDIO"),
  ]
}

extension VoiceAssistantRequestFlag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOICE_ASSISTANT_REQUEST_NONE"),
    1: .same(proto: "VOICE_ASSISTANT_REQUEST_USE_VAD"),
    2: .same(proto: "VOICE_ASSISTANT_REQUEST_USE_WAKE_WORD"),
  ]
}

extension VoiceAssistantEvent: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOICE_ASSISTANT_ERROR"),
    1: .same(proto: "VOICE_ASSISTANT_RUN_START"),
    2: .same(proto: "VOICE_ASSISTANT_RUN_END"),
    3: .same(proto: "VOICE_ASSISTANT_STT_START"),
    4: .same(proto: "VOICE_ASSISTANT_STT_END"),
    5: .same(proto: "VOICE_ASSISTANT_INTENT_START"),
    6: .same(proto: "VOICE_ASSISTANT_INTENT_END"),
    7: .same(proto: "VOICE_ASSISTANT_TTS_START"),
    8: .same(proto: "VOICE_ASSISTANT_TTS_END"),
    9: .same(proto: "VOICE_ASSISTANT_WAKE_WORD_START"),
    10: .same(proto: "VOICE_ASSISTANT_WAKE_WORD_END"),
    11: .same(proto: "VOICE_ASSISTANT_STT_VAD_START"),
    12: .same(proto: "VOICE_ASSISTANT_STT_VAD_END"),
    98: .same(proto: "VOICE_ASSISTANT_TTS_STREAM_START"),
    99: .same(proto: "VOICE_ASSISTANT_TTS_STREAM_END"),
  ]
}

extension VoiceAssistantTimerEvent: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOICE_ASSISTANT_TIMER_STARTED"),
    1: .same(proto: "VOICE_ASSISTANT_TIMER_UPDATED"),
    2: .same(proto: "VOICE_ASSISTANT_TIMER_CANCELLED"),
    3: .same(proto: "VOICE_ASSISTANT_TIMER_FINISHED"),
  ]
}

extension AlarmControlPanelState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALARM_STATE_DISARMED"),
    1: .same(proto: "ALARM_STATE_ARMED_HOME"),
    2: .same(proto: "ALARM_STATE_ARMED_AWAY"),
    3: .same(proto: "ALARM_STATE_ARMED_NIGHT"),
    4: .same(proto: "ALARM_STATE_ARMED_VACATION"),
    5: .same(proto: "ALARM_STATE_ARMED_CUSTOM_BYPASS"),
    6: .same(proto: "ALARM_STATE_PENDING"),
    7: .same(proto: "ALARM_STATE_ARMING"),
    8: .same(proto: "ALARM_STATE_DISARMING"),
    9: .same(proto: "ALARM_STATE_TRIGGERED"),
  ]
}

extension AlarmControlPanelStateCommand: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALARM_CONTROL_PANEL_DISARM"),
    1: .same(proto: "ALARM_CONTROL_PANEL_ARM_AWAY"),
    2: .same(proto: "ALARM_CONTROL_PANEL_ARM_HOME"),
    3: .same(proto: "ALARM_CONTROL_PANEL_ARM_NIGHT"),
    4: .same(proto: "ALARM_CONTROL_PANEL_ARM_VACATION"),
    5: .same(proto: "ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS"),
    6: .same(proto: "ALARM_CONTROL_PANEL_TRIGGER"),
  ]
}

extension TextMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_MODE_TEXT"),
    1: .same(proto: "TEXT_MODE_PASSWORD"),
  ]
}

extension ValveOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VALVE_OPERATION_IDLE"),
    1: .same(proto: "VALVE_OPERATION_IS_OPENING"),
    2: .same(proto: "VALVE_OPERATION_IS_CLOSING"),
  ]
}

extension UpdateCommand: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATE_COMMAND_NONE"),
    1: .same(proto: "UPDATE_COMMAND_UPDATE"),
    2: .same(proto: "UPDATE_COMMAND_CHECK"),
  ]
}

extension HelloRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HelloRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_info"),
    2: .standard(proto: "api_version_major"),
    3: .standard(proto: "api_version_minor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientInfo) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersionMajor) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersionMinor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.clientInfo, fieldNumber: 1)
    }
    if self.apiVersionMajor != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersionMajor, fieldNumber: 2)
    }
    if self.apiVersionMinor != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersionMinor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HelloRequest, rhs: HelloRequest) -> Bool {
    if lhs.clientInfo != rhs.clientInfo {return false}
    if lhs.apiVersionMajor != rhs.apiVersionMajor {return false}
    if lhs.apiVersionMinor != rhs.apiVersionMinor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HelloResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HelloResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "api_version_major"),
    2: .standard(proto: "api_version_minor"),
    3: .standard(proto: "server_info"),
    4: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersionMajor) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.apiVersionMinor) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serverInfo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.apiVersionMajor != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersionMajor, fieldNumber: 1)
    }
    if self.apiVersionMinor != 0 {
      try visitor.visitSingularUInt32Field(value: self.apiVersionMinor, fieldNumber: 2)
    }
    if !self.serverInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.serverInfo, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HelloResponse, rhs: HelloResponse) -> Bool {
    if lhs.apiVersionMajor != rhs.apiVersionMajor {return false}
    if lhs.apiVersionMinor != rhs.apiVersionMinor {return false}
    if lhs.serverInfo != rhs.serverInfo {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConnectRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ConnectRequest, rhs: ConnectRequest) -> Bool {
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ConnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ConnectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invalid_password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.invalidPassword) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.invalidPassword != false {
      try visitor.visitSingularBoolField(value: self.invalidPassword, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ConnectResponse, rhs: ConnectResponse) -> Bool {
    if lhs.invalidPassword != rhs.invalidPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DisconnectRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DisconnectRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DisconnectRequest, rhs: DisconnectRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DisconnectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DisconnectResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DisconnectResponse, rhs: DisconnectResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PingRequest, rhs: PingRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PingResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PingResponse, rhs: PingResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoRequest, rhs: DeviceInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "uses_password"),
    2: .same(proto: "name"),
    3: .standard(proto: "mac_address"),
    4: .standard(proto: "esphome_version"),
    5: .standard(proto: "compilation_time"),
    6: .same(proto: "model"),
    7: .standard(proto: "has_deep_sleep"),
    8: .standard(proto: "project_name"),
    9: .standard(proto: "project_version"),
    10: .standard(proto: "webserver_port"),
    11: .standard(proto: "legacy_bluetooth_proxy_version"),
    15: .standard(proto: "bluetooth_proxy_feature_flags"),
    12: .same(proto: "manufacturer"),
    13: .standard(proto: "friendly_name"),
    14: .standard(proto: "legacy_voice_assistant_version"),
    17: .standard(proto: "voice_assistant_feature_flags"),
    16: .standard(proto: "suggested_area"),
    18: .standard(proto: "bluetooth_mac_address"),
    19: .standard(proto: "api_encryption_supported"),
  ]

  fileprivate class _StorageClass {
    var _usesPassword: Bool = false
    var _name: String = String()
    var _macAddress: String = String()
    var _esphomeVersion: String = String()
    var _compilationTime: String = String()
    var _model: String = String()
    var _hasDeepSleep_p: Bool = false
    var _projectName: String = String()
    var _projectVersion: String = String()
    var _webserverPort: UInt32 = 0
    var _legacyBluetoothProxyVersion: UInt32 = 0
    var _bluetoothProxyFeatureFlags: UInt32 = 0
    var _manufacturer: String = String()
    var _friendlyName: String = String()
    var _legacyVoiceAssistantVersion: UInt32 = 0
    var _voiceAssistantFeatureFlags: UInt32 = 0
    var _suggestedArea: String = String()
    var _bluetoothMacAddress: String = String()
    var _apiEncryptionSupported: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _usesPassword = source._usesPassword
      _name = source._name
      _macAddress = source._macAddress
      _esphomeVersion = source._esphomeVersion
      _compilationTime = source._compilationTime
      _model = source._model
      _hasDeepSleep_p = source._hasDeepSleep_p
      _projectName = source._projectName
      _projectVersion = source._projectVersion
      _webserverPort = source._webserverPort
      _legacyBluetoothProxyVersion = source._legacyBluetoothProxyVersion
      _bluetoothProxyFeatureFlags = source._bluetoothProxyFeatureFlags
      _manufacturer = source._manufacturer
      _friendlyName = source._friendlyName
      _legacyVoiceAssistantVersion = source._legacyVoiceAssistantVersion
      _voiceAssistantFeatureFlags = source._voiceAssistantFeatureFlags
      _suggestedArea = source._suggestedArea
      _bluetoothMacAddress = source._bluetoothMacAddress
      _apiEncryptionSupported = source._apiEncryptionSupported
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._usesPassword) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._macAddress) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._esphomeVersion) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._compilationTime) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._model) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._hasDeepSleep_p) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._projectName) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._projectVersion) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._webserverPort) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._legacyBluetoothProxyVersion) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._manufacturer) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._friendlyName) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._legacyVoiceAssistantVersion) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._bluetoothProxyFeatureFlags) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._suggestedArea) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._voiceAssistantFeatureFlags) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._bluetoothMacAddress) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._apiEncryptionSupported) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._usesPassword != false {
        try visitor.visitSingularBoolField(value: _storage._usesPassword, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._macAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._macAddress, fieldNumber: 3)
      }
      if !_storage._esphomeVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._esphomeVersion, fieldNumber: 4)
      }
      if !_storage._compilationTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._compilationTime, fieldNumber: 5)
      }
      if !_storage._model.isEmpty {
        try visitor.visitSingularStringField(value: _storage._model, fieldNumber: 6)
      }
      if _storage._hasDeepSleep_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasDeepSleep_p, fieldNumber: 7)
      }
      if !_storage._projectName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._projectName, fieldNumber: 8)
      }
      if !_storage._projectVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._projectVersion, fieldNumber: 9)
      }
      if _storage._webserverPort != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._webserverPort, fieldNumber: 10)
      }
      if _storage._legacyBluetoothProxyVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._legacyBluetoothProxyVersion, fieldNumber: 11)
      }
      if !_storage._manufacturer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._manufacturer, fieldNumber: 12)
      }
      if !_storage._friendlyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._friendlyName, fieldNumber: 13)
      }
      if _storage._legacyVoiceAssistantVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._legacyVoiceAssistantVersion, fieldNumber: 14)
      }
      if _storage._bluetoothProxyFeatureFlags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._bluetoothProxyFeatureFlags, fieldNumber: 15)
      }
      if !_storage._suggestedArea.isEmpty {
        try visitor.visitSingularStringField(value: _storage._suggestedArea, fieldNumber: 16)
      }
      if _storage._voiceAssistantFeatureFlags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._voiceAssistantFeatureFlags, fieldNumber: 17)
      }
      if !_storage._bluetoothMacAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bluetoothMacAddress, fieldNumber: 18)
      }
      if _storage._apiEncryptionSupported != false {
        try visitor.visitSingularBoolField(value: _storage._apiEncryptionSupported, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoResponse, rhs: DeviceInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._usesPassword != rhs_storage._usesPassword {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._macAddress != rhs_storage._macAddress {return false}
        if _storage._esphomeVersion != rhs_storage._esphomeVersion {return false}
        if _storage._compilationTime != rhs_storage._compilationTime {return false}
        if _storage._model != rhs_storage._model {return false}
        if _storage._hasDeepSleep_p != rhs_storage._hasDeepSleep_p {return false}
        if _storage._projectName != rhs_storage._projectName {return false}
        if _storage._projectVersion != rhs_storage._projectVersion {return false}
        if _storage._webserverPort != rhs_storage._webserverPort {return false}
        if _storage._legacyBluetoothProxyVersion != rhs_storage._legacyBluetoothProxyVersion {return false}
        if _storage._bluetoothProxyFeatureFlags != rhs_storage._bluetoothProxyFeatureFlags {return false}
        if _storage._manufacturer != rhs_storage._manufacturer {return false}
        if _storage._friendlyName != rhs_storage._friendlyName {return false}
        if _storage._legacyVoiceAssistantVersion != rhs_storage._legacyVoiceAssistantVersion {return false}
        if _storage._voiceAssistantFeatureFlags != rhs_storage._voiceAssistantFeatureFlags {return false}
        if _storage._suggestedArea != rhs_storage._suggestedArea {return false}
        if _storage._bluetoothMacAddress != rhs_storage._bluetoothMacAddress {return false}
        if _storage._apiEncryptionSupported != rhs_storage._apiEncryptionSupported {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesRequest, rhs: ListEntitiesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesDoneResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesDoneResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesDoneResponse, rhs: ListEntitiesDoneResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeStatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubscribeStatesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubscribeStatesRequest, rhs: SubscribeStatesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesBinarySensorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesBinarySensorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .standard(proto: "device_class"),
    6: .standard(proto: "is_status_binary_sensor"),
    7: .standard(proto: "disabled_by_default"),
    8: .same(proto: "icon"),
    9: .standard(proto: "entity_category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.deviceClass) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isStatusBinarySensor) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.deviceClass.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceClass, fieldNumber: 5)
    }
    if self.isStatusBinarySensor != false {
      try visitor.visitSingularBoolField(value: self.isStatusBinarySensor, fieldNumber: 6)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 7)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 8)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesBinarySensorResponse, rhs: ListEntitiesBinarySensorResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.isStatusBinarySensor != rhs.isStatusBinarySensor {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BinarySensorStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BinarySensorStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
    3: .standard(proto: "missing_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.missingState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 2)
    }
    if self.missingState != false {
      try visitor.visitSingularBoolField(value: self.missingState, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BinarySensorStateResponse, rhs: BinarySensorStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.missingState != rhs.missingState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesCoverResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesCoverResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .standard(proto: "assumed_state"),
    6: .standard(proto: "supports_position"),
    7: .standard(proto: "supports_tilt"),
    8: .standard(proto: "device_class"),
    9: .standard(proto: "disabled_by_default"),
    10: .same(proto: "icon"),
    11: .standard(proto: "entity_category"),
    12: .standard(proto: "supports_stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.assumedState) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.supportsPosition) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.supportsTilt) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.deviceClass) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.supportsStop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if self.assumedState != false {
      try visitor.visitSingularBoolField(value: self.assumedState, fieldNumber: 5)
    }
    if self.supportsPosition != false {
      try visitor.visitSingularBoolField(value: self.supportsPosition, fieldNumber: 6)
    }
    if self.supportsTilt != false {
      try visitor.visitSingularBoolField(value: self.supportsTilt, fieldNumber: 7)
    }
    if !self.deviceClass.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceClass, fieldNumber: 8)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 9)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 10)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 11)
    }
    if self.supportsStop != false {
      try visitor.visitSingularBoolField(value: self.supportsStop, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesCoverResponse, rhs: ListEntitiesCoverResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.assumedState != rhs.assumedState {return false}
    if lhs.supportsPosition != rhs.supportsPosition {return false}
    if lhs.supportsTilt != rhs.supportsTilt {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.supportsStop != rhs.supportsStop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoverStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CoverStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "legacy_state"),
    3: .same(proto: "position"),
    4: .same(proto: "tilt"),
    5: .standard(proto: "current_operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.legacyState) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.position) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.tilt) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.currentOperation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.legacyState != .open {
      try visitor.visitSingularEnumField(value: self.legacyState, fieldNumber: 2)
    }
    if self.position.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.position, fieldNumber: 3)
    }
    if self.tilt.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.tilt, fieldNumber: 4)
    }
    if self.currentOperation != .idle {
      try visitor.visitSingularEnumField(value: self.currentOperation, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoverStateResponse, rhs: CoverStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.legacyState != rhs.legacyState {return false}
    if lhs.position != rhs.position {return false}
    if lhs.tilt != rhs.tilt {return false}
    if lhs.currentOperation != rhs.currentOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoverCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CoverCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "has_legacy_command"),
    3: .standard(proto: "legacy_command"),
    4: .standard(proto: "has_position"),
    5: .same(proto: "position"),
    6: .standard(proto: "has_tilt"),
    7: .same(proto: "tilt"),
    8: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasLegacyCommand_p) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.legacyCommand) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.hasPosition_p) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.position) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.hasTilt_p) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.tilt) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.stop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.hasLegacyCommand_p != false {
      try visitor.visitSingularBoolField(value: self.hasLegacyCommand_p, fieldNumber: 2)
    }
    if self.legacyCommand != .open {
      try visitor.visitSingularEnumField(value: self.legacyCommand, fieldNumber: 3)
    }
    if self.hasPosition_p != false {
      try visitor.visitSingularBoolField(value: self.hasPosition_p, fieldNumber: 4)
    }
    if self.position.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.position, fieldNumber: 5)
    }
    if self.hasTilt_p != false {
      try visitor.visitSingularBoolField(value: self.hasTilt_p, fieldNumber: 6)
    }
    if self.tilt.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.tilt, fieldNumber: 7)
    }
    if self.stop != false {
      try visitor.visitSingularBoolField(value: self.stop, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoverCommandRequest, rhs: CoverCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.hasLegacyCommand_p != rhs.hasLegacyCommand_p {return false}
    if lhs.legacyCommand != rhs.legacyCommand {return false}
    if lhs.hasPosition_p != rhs.hasPosition_p {return false}
    if lhs.position != rhs.position {return false}
    if lhs.hasTilt_p != rhs.hasTilt_p {return false}
    if lhs.tilt != rhs.tilt {return false}
    if lhs.stop != rhs.stop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesFanResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesFanResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .standard(proto: "supports_oscillation"),
    6: .standard(proto: "supports_speed"),
    7: .standard(proto: "supports_direction"),
    8: .standard(proto: "supported_speed_count"),
    9: .standard(proto: "disabled_by_default"),
    10: .same(proto: "icon"),
    11: .standard(proto: "entity_category"),
    12: .standard(proto: "supported_preset_modes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.supportsOscillation) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.supportsSpeed) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.supportsDirection) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.supportedSpeedCount) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 12: try { try decoder.decodeRepeatedStringField(value: &self.supportedPresetModes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if self.supportsOscillation != false {
      try visitor.visitSingularBoolField(value: self.supportsOscillation, fieldNumber: 5)
    }
    if self.supportsSpeed != false {
      try visitor.visitSingularBoolField(value: self.supportsSpeed, fieldNumber: 6)
    }
    if self.supportsDirection != false {
      try visitor.visitSingularBoolField(value: self.supportsDirection, fieldNumber: 7)
    }
    if self.supportedSpeedCount != 0 {
      try visitor.visitSingularInt32Field(value: self.supportedSpeedCount, fieldNumber: 8)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 9)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 10)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 11)
    }
    if !self.supportedPresetModes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.supportedPresetModes, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesFanResponse, rhs: ListEntitiesFanResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.supportsOscillation != rhs.supportsOscillation {return false}
    if lhs.supportsSpeed != rhs.supportsSpeed {return false}
    if lhs.supportsDirection != rhs.supportsDirection {return false}
    if lhs.supportedSpeedCount != rhs.supportedSpeedCount {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.supportedPresetModes != rhs.supportedPresetModes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FanStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FanStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
    3: .same(proto: "oscillating"),
    4: .same(proto: "speed"),
    5: .same(proto: "direction"),
    6: .standard(proto: "speed_level"),
    7: .standard(proto: "preset_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.oscillating) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.speed) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.speedLevel) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.presetMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 2)
    }
    if self.oscillating != false {
      try visitor.visitSingularBoolField(value: self.oscillating, fieldNumber: 3)
    }
    if self.speed != .low {
      try visitor.visitSingularEnumField(value: self.speed, fieldNumber: 4)
    }
    if self.direction != .forward {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 5)
    }
    if self.speedLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.speedLevel, fieldNumber: 6)
    }
    if !self.presetMode.isEmpty {
      try visitor.visitSingularStringField(value: self.presetMode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FanStateResponse, rhs: FanStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.oscillating != rhs.oscillating {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.speedLevel != rhs.speedLevel {return false}
    if lhs.presetMode != rhs.presetMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FanCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FanCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "has_state"),
    3: .same(proto: "state"),
    4: .standard(proto: "has_speed"),
    5: .same(proto: "speed"),
    6: .standard(proto: "has_oscillating"),
    7: .same(proto: "oscillating"),
    8: .standard(proto: "has_direction"),
    9: .same(proto: "direction"),
    10: .standard(proto: "has_speed_level"),
    11: .standard(proto: "speed_level"),
    12: .standard(proto: "has_preset_mode"),
    13: .standard(proto: "preset_mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasState_p) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.hasSpeed_p) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.speed) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.hasOscillating_p) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.oscillating) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hasDirection_p) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.hasSpeedLevel_p) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.speedLevel) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.hasPresetMode_p) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.presetMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.hasState_p != false {
      try visitor.visitSingularBoolField(value: self.hasState_p, fieldNumber: 2)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 3)
    }
    if self.hasSpeed_p != false {
      try visitor.visitSingularBoolField(value: self.hasSpeed_p, fieldNumber: 4)
    }
    if self.speed != .low {
      try visitor.visitSingularEnumField(value: self.speed, fieldNumber: 5)
    }
    if self.hasOscillating_p != false {
      try visitor.visitSingularBoolField(value: self.hasOscillating_p, fieldNumber: 6)
    }
    if self.oscillating != false {
      try visitor.visitSingularBoolField(value: self.oscillating, fieldNumber: 7)
    }
    if self.hasDirection_p != false {
      try visitor.visitSingularBoolField(value: self.hasDirection_p, fieldNumber: 8)
    }
    if self.direction != .forward {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 9)
    }
    if self.hasSpeedLevel_p != false {
      try visitor.visitSingularBoolField(value: self.hasSpeedLevel_p, fieldNumber: 10)
    }
    if self.speedLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.speedLevel, fieldNumber: 11)
    }
    if self.hasPresetMode_p != false {
      try visitor.visitSingularBoolField(value: self.hasPresetMode_p, fieldNumber: 12)
    }
    if !self.presetMode.isEmpty {
      try visitor.visitSingularStringField(value: self.presetMode, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FanCommandRequest, rhs: FanCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.hasState_p != rhs.hasState_p {return false}
    if lhs.state != rhs.state {return false}
    if lhs.hasSpeed_p != rhs.hasSpeed_p {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.hasOscillating_p != rhs.hasOscillating_p {return false}
    if lhs.oscillating != rhs.oscillating {return false}
    if lhs.hasDirection_p != rhs.hasDirection_p {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.hasSpeedLevel_p != rhs.hasSpeedLevel_p {return false}
    if lhs.speedLevel != rhs.speedLevel {return false}
    if lhs.hasPresetMode_p != rhs.hasPresetMode_p {return false}
    if lhs.presetMode != rhs.presetMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesLightResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesLightResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    12: .standard(proto: "supported_color_modes"),
    5: .standard(proto: "legacy_supports_brightness"),
    6: .standard(proto: "legacy_supports_rgb"),
    7: .standard(proto: "legacy_supports_white_value"),
    8: .standard(proto: "legacy_supports_color_temperature"),
    9: .standard(proto: "min_mireds"),
    10: .standard(proto: "max_mireds"),
    11: .same(proto: "effects"),
    13: .standard(proto: "disabled_by_default"),
    14: .same(proto: "icon"),
    15: .standard(proto: "entity_category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.legacySupportsBrightness) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.legacySupportsRgb) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.legacySupportsWhiteValue) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.legacySupportsColorTemperature) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.minMireds) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.maxMireds) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.effects) }()
      case 12: try { try decoder.decodeRepeatedEnumField(value: &self.supportedColorModes) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 15: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if self.legacySupportsBrightness != false {
      try visitor.visitSingularBoolField(value: self.legacySupportsBrightness, fieldNumber: 5)
    }
    if self.legacySupportsRgb != false {
      try visitor.visitSingularBoolField(value: self.legacySupportsRgb, fieldNumber: 6)
    }
    if self.legacySupportsWhiteValue != false {
      try visitor.visitSingularBoolField(value: self.legacySupportsWhiteValue, fieldNumber: 7)
    }
    if self.legacySupportsColorTemperature != false {
      try visitor.visitSingularBoolField(value: self.legacySupportsColorTemperature, fieldNumber: 8)
    }
    if self.minMireds.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.minMireds, fieldNumber: 9)
    }
    if self.maxMireds.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.maxMireds, fieldNumber: 10)
    }
    if !self.effects.isEmpty {
      try visitor.visitRepeatedStringField(value: self.effects, fieldNumber: 11)
    }
    if !self.supportedColorModes.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportedColorModes, fieldNumber: 12)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 13)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 14)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesLightResponse, rhs: ListEntitiesLightResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.supportedColorModes != rhs.supportedColorModes {return false}
    if lhs.legacySupportsBrightness != rhs.legacySupportsBrightness {return false}
    if lhs.legacySupportsRgb != rhs.legacySupportsRgb {return false}
    if lhs.legacySupportsWhiteValue != rhs.legacySupportsWhiteValue {return false}
    if lhs.legacySupportsColorTemperature != rhs.legacySupportsColorTemperature {return false}
    if lhs.minMireds != rhs.minMireds {return false}
    if lhs.maxMireds != rhs.maxMireds {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LightStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LightStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
    3: .same(proto: "brightness"),
    11: .standard(proto: "color_mode"),
    10: .standard(proto: "color_brightness"),
    4: .same(proto: "red"),
    5: .same(proto: "green"),
    6: .same(proto: "blue"),
    7: .same(proto: "white"),
    8: .standard(proto: "color_temperature"),
    12: .standard(proto: "cold_white"),
    13: .standard(proto: "warm_white"),
    9: .same(proto: "effect"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.brightness) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.red) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.green) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.blue) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.white) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.colorTemperature) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.effect) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.colorBrightness) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.colorMode) }()
      case 12: try { try decoder.decodeSingularFloatField(value: &self.coldWhite) }()
      case 13: try { try decoder.decodeSingularFloatField(value: &self.warmWhite) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 2)
    }
    if self.brightness.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.brightness, fieldNumber: 3)
    }
    if self.red.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.red, fieldNumber: 4)
    }
    if self.green.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.green, fieldNumber: 5)
    }
    if self.blue.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.blue, fieldNumber: 6)
    }
    if self.white.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.white, fieldNumber: 7)
    }
    if self.colorTemperature.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.colorTemperature, fieldNumber: 8)
    }
    if !self.effect.isEmpty {
      try visitor.visitSingularStringField(value: self.effect, fieldNumber: 9)
    }
    if self.colorBrightness.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.colorBrightness, fieldNumber: 10)
    }
    if self.colorMode != .unknown {
      try visitor.visitSingularEnumField(value: self.colorMode, fieldNumber: 11)
    }
    if self.coldWhite.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.coldWhite, fieldNumber: 12)
    }
    if self.warmWhite.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.warmWhite, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LightStateResponse, rhs: LightStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.brightness != rhs.brightness {return false}
    if lhs.colorMode != rhs.colorMode {return false}
    if lhs.colorBrightness != rhs.colorBrightness {return false}
    if lhs.red != rhs.red {return false}
    if lhs.green != rhs.green {return false}
    if lhs.blue != rhs.blue {return false}
    if lhs.white != rhs.white {return false}
    if lhs.colorTemperature != rhs.colorTemperature {return false}
    if lhs.coldWhite != rhs.coldWhite {return false}
    if lhs.warmWhite != rhs.warmWhite {return false}
    if lhs.effect != rhs.effect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LightCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LightCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "has_state"),
    3: .same(proto: "state"),
    4: .standard(proto: "has_brightness"),
    5: .same(proto: "brightness"),
    22: .standard(proto: "has_color_mode"),
    23: .standard(proto: "color_mode"),
    20: .standard(proto: "has_color_brightness"),
    21: .standard(proto: "color_brightness"),
    6: .standard(proto: "has_rgb"),
    7: .same(proto: "red"),
    8: .same(proto: "green"),
    9: .same(proto: "blue"),
    10: .standard(proto: "has_white"),
    11: .same(proto: "white"),
    12: .standard(proto: "has_color_temperature"),
    13: .standard(proto: "color_temperature"),
    24: .standard(proto: "has_cold_white"),
    25: .standard(proto: "cold_white"),
    26: .standard(proto: "has_warm_white"),
    27: .standard(proto: "warm_white"),
    14: .standard(proto: "has_transition_length"),
    15: .standard(proto: "transition_length"),
    16: .standard(proto: "has_flash_length"),
    17: .standard(proto: "flash_length"),
    18: .standard(proto: "has_effect"),
    19: .same(proto: "effect"),
  ]

  fileprivate class _StorageClass {
    var _key: UInt32 = 0
    var _hasState_p: Bool = false
    var _state: Bool = false
    var _hasBrightness_p: Bool = false
    var _brightness: Float = 0
    var _hasColorMode_p: Bool = false
    var _colorMode: ColorMode = .unknown
    var _hasColorBrightness_p: Bool = false
    var _colorBrightness: Float = 0
    var _hasRgb_p: Bool = false
    var _red: Float = 0
    var _green: Float = 0
    var _blue: Float = 0
    var _hasWhite_p: Bool = false
    var _white: Float = 0
    var _hasColorTemperature_p: Bool = false
    var _colorTemperature: Float = 0
    var _hasColdWhite_p: Bool = false
    var _coldWhite: Float = 0
    var _hasWarmWhite_p: Bool = false
    var _warmWhite: Float = 0
    var _hasTransitionLength_p: Bool = false
    var _transitionLength: UInt32 = 0
    var _hasFlashLength_p: Bool = false
    var _flashLength: UInt32 = 0
    var _hasEffect_p: Bool = false
    var _effect: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _hasState_p = source._hasState_p
      _state = source._state
      _hasBrightness_p = source._hasBrightness_p
      _brightness = source._brightness
      _hasColorMode_p = source._hasColorMode_p
      _colorMode = source._colorMode
      _hasColorBrightness_p = source._hasColorBrightness_p
      _colorBrightness = source._colorBrightness
      _hasRgb_p = source._hasRgb_p
      _red = source._red
      _green = source._green
      _blue = source._blue
      _hasWhite_p = source._hasWhite_p
      _white = source._white
      _hasColorTemperature_p = source._hasColorTemperature_p
      _colorTemperature = source._colorTemperature
      _hasColdWhite_p = source._hasColdWhite_p
      _coldWhite = source._coldWhite
      _hasWarmWhite_p = source._hasWarmWhite_p
      _warmWhite = source._warmWhite
      _hasTransitionLength_p = source._hasTransitionLength_p
      _transitionLength = source._transitionLength
      _hasFlashLength_p = source._hasFlashLength_p
      _flashLength = source._flashLength
      _hasEffect_p = source._hasEffect_p
      _effect = source._effect
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed32Field(value: &_storage._key) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._hasState_p) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._hasBrightness_p) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._brightness) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._hasRgb_p) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._red) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._green) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._blue) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._hasWhite_p) }()
        case 11: try { try decoder.decodeSingularFloatField(value: &_storage._white) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._hasColorTemperature_p) }()
        case 13: try { try decoder.decodeSingularFloatField(value: &_storage._colorTemperature) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._hasTransitionLength_p) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._transitionLength) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._hasFlashLength_p) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._flashLength) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._hasEffect_p) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._effect) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._hasColorBrightness_p) }()
        case 21: try { try decoder.decodeSingularFloatField(value: &_storage._colorBrightness) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._hasColorMode_p) }()
        case 23: try { try decoder.decodeSingularEnumField(value: &_storage._colorMode) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._hasColdWhite_p) }()
        case 25: try { try decoder.decodeSingularFloatField(value: &_storage._coldWhite) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._hasWarmWhite_p) }()
        case 27: try { try decoder.decodeSingularFloatField(value: &_storage._warmWhite) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._key != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._key, fieldNumber: 1)
      }
      if _storage._hasState_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasState_p, fieldNumber: 2)
      }
      if _storage._state != false {
        try visitor.visitSingularBoolField(value: _storage._state, fieldNumber: 3)
      }
      if _storage._hasBrightness_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasBrightness_p, fieldNumber: 4)
      }
      if _storage._brightness.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._brightness, fieldNumber: 5)
      }
      if _storage._hasRgb_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasRgb_p, fieldNumber: 6)
      }
      if _storage._red.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._red, fieldNumber: 7)
      }
      if _storage._green.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._green, fieldNumber: 8)
      }
      if _storage._blue.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._blue, fieldNumber: 9)
      }
      if _storage._hasWhite_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasWhite_p, fieldNumber: 10)
      }
      if _storage._white.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._white, fieldNumber: 11)
      }
      if _storage._hasColorTemperature_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasColorTemperature_p, fieldNumber: 12)
      }
      if _storage._colorTemperature.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._colorTemperature, fieldNumber: 13)
      }
      if _storage._hasTransitionLength_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasTransitionLength_p, fieldNumber: 14)
      }
      if _storage._transitionLength != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._transitionLength, fieldNumber: 15)
      }
      if _storage._hasFlashLength_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasFlashLength_p, fieldNumber: 16)
      }
      if _storage._flashLength != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flashLength, fieldNumber: 17)
      }
      if _storage._hasEffect_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasEffect_p, fieldNumber: 18)
      }
      if !_storage._effect.isEmpty {
        try visitor.visitSingularStringField(value: _storage._effect, fieldNumber: 19)
      }
      if _storage._hasColorBrightness_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasColorBrightness_p, fieldNumber: 20)
      }
      if _storage._colorBrightness.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._colorBrightness, fieldNumber: 21)
      }
      if _storage._hasColorMode_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasColorMode_p, fieldNumber: 22)
      }
      if _storage._colorMode != .unknown {
        try visitor.visitSingularEnumField(value: _storage._colorMode, fieldNumber: 23)
      }
      if _storage._hasColdWhite_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasColdWhite_p, fieldNumber: 24)
      }
      if _storage._coldWhite.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._coldWhite, fieldNumber: 25)
      }
      if _storage._hasWarmWhite_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasWarmWhite_p, fieldNumber: 26)
      }
      if _storage._warmWhite.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._warmWhite, fieldNumber: 27)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LightCommandRequest, rhs: LightCommandRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._hasState_p != rhs_storage._hasState_p {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._hasBrightness_p != rhs_storage._hasBrightness_p {return false}
        if _storage._brightness != rhs_storage._brightness {return false}
        if _storage._hasColorMode_p != rhs_storage._hasColorMode_p {return false}
        if _storage._colorMode != rhs_storage._colorMode {return false}
        if _storage._hasColorBrightness_p != rhs_storage._hasColorBrightness_p {return false}
        if _storage._colorBrightness != rhs_storage._colorBrightness {return false}
        if _storage._hasRgb_p != rhs_storage._hasRgb_p {return false}
        if _storage._red != rhs_storage._red {return false}
        if _storage._green != rhs_storage._green {return false}
        if _storage._blue != rhs_storage._blue {return false}
        if _storage._hasWhite_p != rhs_storage._hasWhite_p {return false}
        if _storage._white != rhs_storage._white {return false}
        if _storage._hasColorTemperature_p != rhs_storage._hasColorTemperature_p {return false}
        if _storage._colorTemperature != rhs_storage._colorTemperature {return false}
        if _storage._hasColdWhite_p != rhs_storage._hasColdWhite_p {return false}
        if _storage._coldWhite != rhs_storage._coldWhite {return false}
        if _storage._hasWarmWhite_p != rhs_storage._hasWarmWhite_p {return false}
        if _storage._warmWhite != rhs_storage._warmWhite {return false}
        if _storage._hasTransitionLength_p != rhs_storage._hasTransitionLength_p {return false}
        if _storage._transitionLength != rhs_storage._transitionLength {return false}
        if _storage._hasFlashLength_p != rhs_storage._hasFlashLength_p {return false}
        if _storage._flashLength != rhs_storage._flashLength {return false}
        if _storage._hasEffect_p != rhs_storage._hasEffect_p {return false}
        if _storage._effect != rhs_storage._effect {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesSensorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesSensorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "unit_of_measurement"),
    7: .standard(proto: "accuracy_decimals"),
    8: .standard(proto: "force_update"),
    9: .standard(proto: "device_class"),
    10: .standard(proto: "state_class"),
    11: .standard(proto: "legacy_last_reset_type"),
    12: .standard(proto: "disabled_by_default"),
    13: .standard(proto: "entity_category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.unitOfMeasurement) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.accuracyDecimals) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.forceUpdate) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.deviceClass) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.stateClass) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.legacyLastResetType) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if !self.unitOfMeasurement.isEmpty {
      try visitor.visitSingularStringField(value: self.unitOfMeasurement, fieldNumber: 6)
    }
    if self.accuracyDecimals != 0 {
      try visitor.visitSingularInt32Field(value: self.accuracyDecimals, fieldNumber: 7)
    }
    if self.forceUpdate != false {
      try visitor.visitSingularBoolField(value: self.forceUpdate, fieldNumber: 8)
    }
    if !self.deviceClass.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceClass, fieldNumber: 9)
    }
    if self.stateClass != .stateClassNone {
      try visitor.visitSingularEnumField(value: self.stateClass, fieldNumber: 10)
    }
    if self.legacyLastResetType != .lastResetNone {
      try visitor.visitSingularEnumField(value: self.legacyLastResetType, fieldNumber: 11)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 12)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesSensorResponse, rhs: ListEntitiesSensorResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.unitOfMeasurement != rhs.unitOfMeasurement {return false}
    if lhs.accuracyDecimals != rhs.accuracyDecimals {return false}
    if lhs.forceUpdate != rhs.forceUpdate {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.stateClass != rhs.stateClass {return false}
    if lhs.legacyLastResetType != rhs.legacyLastResetType {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
    3: .standard(proto: "missing_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.missingState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.state, fieldNumber: 2)
    }
    if self.missingState != false {
      try visitor.visitSingularBoolField(value: self.missingState, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorStateResponse, rhs: SensorStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.missingState != rhs.missingState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesSwitchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesSwitchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "assumed_state"),
    7: .standard(proto: "disabled_by_default"),
    8: .standard(proto: "entity_category"),
    9: .standard(proto: "device_class"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.assumedState) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.deviceClass) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.assumedState != false {
      try visitor.visitSingularBoolField(value: self.assumedState, fieldNumber: 6)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 7)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 8)
    }
    if !self.deviceClass.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceClass, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesSwitchResponse, rhs: ListEntitiesSwitchResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.assumedState != rhs.assumedState {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwitchStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SwitchStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SwitchStateResponse, rhs: SwitchStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SwitchCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SwitchCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SwitchCommandRequest, rhs: SwitchCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesTextSensorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesTextSensorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
    8: .standard(proto: "device_class"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.deviceClass) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    if !self.deviceClass.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceClass, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesTextSensorResponse, rhs: ListEntitiesTextSensorResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TextSensorStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TextSensorStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
    3: .standard(proto: "missing_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.missingState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 2)
    }
    if self.missingState != false {
      try visitor.visitSingularBoolField(value: self.missingState, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TextSensorStateResponse, rhs: TextSensorStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.missingState != rhs.missingState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeLogsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubscribeLogsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .standard(proto: "dump_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.dumpConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.level != .none {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 1)
    }
    if self.dumpConfig != false {
      try visitor.visitSingularBoolField(value: self.dumpConfig, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubscribeLogsRequest, rhs: SubscribeLogsRequest) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.dumpConfig != rhs.dumpConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeLogsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubscribeLogsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    3: .same(proto: "message"),
    4: .standard(proto: "send_failed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.level) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.message) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sendFailed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.level != .none {
      try visitor.visitSingularEnumField(value: self.level, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 3)
    }
    if self.sendFailed != false {
      try visitor.visitSingularBoolField(value: self.sendFailed, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubscribeLogsResponse, rhs: SubscribeLogsResponse) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.message != rhs.message {return false}
    if lhs.sendFailed != rhs.sendFailed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NoiseEncryptionSetKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NoiseEncryptionSetKeyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NoiseEncryptionSetKeyRequest, rhs: NoiseEncryptionSetKeyRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NoiseEncryptionSetKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NoiseEncryptionSetKeyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NoiseEncryptionSetKeyResponse, rhs: NoiseEncryptionSetKeyResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeHomeassistantServicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubscribeHomeassistantServicesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubscribeHomeassistantServicesRequest, rhs: SubscribeHomeassistantServicesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HomeassistantServiceMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HomeassistantServiceMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HomeassistantServiceMap, rhs: HomeassistantServiceMap) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HomeassistantServiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HomeassistantServiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service"),
    2: .same(proto: "data"),
    3: .standard(proto: "data_template"),
    4: .same(proto: "variables"),
    5: .standard(proto: "is_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.dataTemplate) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.variables) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isEvent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    if !self.dataTemplate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataTemplate, fieldNumber: 3)
    }
    if !self.variables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variables, fieldNumber: 4)
    }
    if self.isEvent != false {
      try visitor.visitSingularBoolField(value: self.isEvent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HomeassistantServiceResponse, rhs: HomeassistantServiceResponse) -> Bool {
    if lhs.service != rhs.service {return false}
    if lhs.data != rhs.data {return false}
    if lhs.dataTemplate != rhs.dataTemplate {return false}
    if lhs.variables != rhs.variables {return false}
    if lhs.isEvent != rhs.isEvent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeHomeAssistantStatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubscribeHomeAssistantStatesRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubscribeHomeAssistantStatesRequest, rhs: SubscribeHomeAssistantStatesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeHomeAssistantStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubscribeHomeAssistantStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .same(proto: "attribute"),
    3: .same(proto: "once"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.attribute) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.once) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 1)
    }
    if !self.attribute.isEmpty {
      try visitor.visitSingularStringField(value: self.attribute, fieldNumber: 2)
    }
    if self.once != false {
      try visitor.visitSingularBoolField(value: self.once, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubscribeHomeAssistantStateResponse, rhs: SubscribeHomeAssistantStateResponse) -> Bool {
    if lhs.entityID != rhs.entityID {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.once != rhs.once {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HomeAssistantStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HomeAssistantStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entity_id"),
    2: .same(proto: "state"),
    3: .same(proto: "attribute"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.entityID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.attribute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entityID.isEmpty {
      try visitor.visitSingularStringField(value: self.entityID, fieldNumber: 1)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 2)
    }
    if !self.attribute.isEmpty {
      try visitor.visitSingularStringField(value: self.attribute, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HomeAssistantStateResponse, rhs: HomeAssistantStateResponse) -> Bool {
    if lhs.entityID != rhs.entityID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTimeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetTimeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetTimeRequest, rhs: GetTimeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetTimeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetTimeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.epochSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochSeconds != 0 {
      try visitor.visitSingularFixed32Field(value: self.epochSeconds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetTimeResponse, rhs: GetTimeResponse) -> Bool {
    if lhs.epochSeconds != rhs.epochSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesServicesArgument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesServicesArgument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .bool {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesServicesArgument, rhs: ListEntitiesServicesArgument) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesServicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesServicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "key"),
    3: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.args, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesServicesResponse, rhs: ListEntitiesServicesResponse) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.key != rhs.key {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExecuteServiceArgument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ExecuteServiceArgument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bool_"),
    2: .standard(proto: "legacy_int"),
    3: .standard(proto: "float_"),
    4: .standard(proto: "string_"),
    5: .standard(proto: "int_"),
    6: .standard(proto: "bool_array"),
    7: .standard(proto: "int_array"),
    8: .standard(proto: "float_array"),
    9: .standard(proto: "string_array"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.bool_) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.legacyInt) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.float_) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.string_) }()
      case 5: try { try decoder.decodeSingularSInt32Field(value: &self.int_) }()
      case 6: try { try decoder.decodeRepeatedBoolField(value: &self.boolArray) }()
      case 7: try { try decoder.decodeRepeatedSInt32Field(value: &self.intArray) }()
      case 8: try { try decoder.decodeRepeatedFloatField(value: &self.floatArray) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.stringArray) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bool_ != false {
      try visitor.visitSingularBoolField(value: self.bool_, fieldNumber: 1)
    }
    if self.legacyInt != 0 {
      try visitor.visitSingularInt32Field(value: self.legacyInt, fieldNumber: 2)
    }
    if self.float_.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.float_, fieldNumber: 3)
    }
    if !self.string_.isEmpty {
      try visitor.visitSingularStringField(value: self.string_, fieldNumber: 4)
    }
    if self.int_ != 0 {
      try visitor.visitSingularSInt32Field(value: self.int_, fieldNumber: 5)
    }
    if !self.boolArray.isEmpty {
      try visitor.visitRepeatedBoolField(value: self.boolArray, fieldNumber: 6)
    }
    if !self.intArray.isEmpty {
      try visitor.visitRepeatedSInt32Field(value: self.intArray, fieldNumber: 7)
    }
    if !self.floatArray.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.floatArray, fieldNumber: 8)
    }
    if !self.stringArray.isEmpty {
      try visitor.visitRepeatedStringField(value: self.stringArray, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ExecuteServiceArgument, rhs: ExecuteServiceArgument) -> Bool {
    if lhs.bool_ != rhs.bool_ {return false}
    if lhs.legacyInt != rhs.legacyInt {return false}
    if lhs.float_ != rhs.float_ {return false}
    if lhs.string_ != rhs.string_ {return false}
    if lhs.int_ != rhs.int_ {return false}
    if lhs.boolArray != rhs.boolArray {return false}
    if lhs.intArray != rhs.intArray {return false}
    if lhs.floatArray != rhs.floatArray {return false}
    if lhs.stringArray != rhs.stringArray {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ExecuteServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ExecuteServiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "args"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.args) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.args, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ExecuteServiceRequest, rhs: ExecuteServiceRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesCameraResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesCameraResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .standard(proto: "disabled_by_default"),
    6: .same(proto: "icon"),
    7: .standard(proto: "entity_category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 5)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesCameraResponse, rhs: ListEntitiesCameraResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CameraImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CameraImageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "data"),
    3: .same(proto: "done"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CameraImageResponse, rhs: CameraImageResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.data != rhs.data {return false}
    if lhs.done != rhs.done {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CameraImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CameraImageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "single"),
    2: .same(proto: "stream"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.single) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.stream) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.single != false {
      try visitor.visitSingularBoolField(value: self.single, fieldNumber: 1)
    }
    if self.stream != false {
      try visitor.visitSingularBoolField(value: self.stream, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CameraImageRequest, rhs: CameraImageRequest) -> Bool {
    if lhs.single != rhs.single {return false}
    if lhs.stream != rhs.stream {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesClimateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesClimateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .standard(proto: "supports_current_temperature"),
    6: .standard(proto: "supports_two_point_target_temperature"),
    7: .standard(proto: "supported_modes"),
    8: .standard(proto: "visual_min_temperature"),
    9: .standard(proto: "visual_max_temperature"),
    10: .standard(proto: "visual_target_temperature_step"),
    11: .standard(proto: "legacy_supports_away"),
    12: .standard(proto: "supports_action"),
    13: .standard(proto: "supported_fan_modes"),
    14: .standard(proto: "supported_swing_modes"),
    15: .standard(proto: "supported_custom_fan_modes"),
    16: .standard(proto: "supported_presets"),
    17: .standard(proto: "supported_custom_presets"),
    18: .standard(proto: "disabled_by_default"),
    19: .same(proto: "icon"),
    20: .standard(proto: "entity_category"),
    21: .standard(proto: "visual_current_temperature_step"),
    22: .standard(proto: "supports_current_humidity"),
    23: .standard(proto: "supports_target_humidity"),
    24: .standard(proto: "visual_min_humidity"),
    25: .standard(proto: "visual_max_humidity"),
  ]

  fileprivate class _StorageClass {
    var _objectID: String = String()
    var _key: UInt32 = 0
    var _name: String = String()
    var _uniqueID: String = String()
    var _supportsCurrentTemperature: Bool = false
    var _supportsTwoPointTargetTemperature: Bool = false
    var _supportedModes: [ClimateMode] = []
    var _visualMinTemperature: Float = 0
    var _visualMaxTemperature: Float = 0
    var _visualTargetTemperatureStep: Float = 0
    var _legacySupportsAway: Bool = false
    var _supportsAction: Bool = false
    var _supportedFanModes: [ClimateFanMode] = []
    var _supportedSwingModes: [ClimateSwingMode] = []
    var _supportedCustomFanModes: [String] = []
    var _supportedPresets: [ClimatePreset] = []
    var _supportedCustomPresets: [String] = []
    var _disabledByDefault: Bool = false
    var _icon: String = String()
    var _entityCategory: EntityCategory = .none
    var _visualCurrentTemperatureStep: Float = 0
    var _supportsCurrentHumidity: Bool = false
    var _supportsTargetHumidity: Bool = false
    var _visualMinHumidity: Float = 0
    var _visualMaxHumidity: Float = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _objectID = source._objectID
      _key = source._key
      _name = source._name
      _uniqueID = source._uniqueID
      _supportsCurrentTemperature = source._supportsCurrentTemperature
      _supportsTwoPointTargetTemperature = source._supportsTwoPointTargetTemperature
      _supportedModes = source._supportedModes
      _visualMinTemperature = source._visualMinTemperature
      _visualMaxTemperature = source._visualMaxTemperature
      _visualTargetTemperatureStep = source._visualTargetTemperatureStep
      _legacySupportsAway = source._legacySupportsAway
      _supportsAction = source._supportsAction
      _supportedFanModes = source._supportedFanModes
      _supportedSwingModes = source._supportedSwingModes
      _supportedCustomFanModes = source._supportedCustomFanModes
      _supportedPresets = source._supportedPresets
      _supportedCustomPresets = source._supportedCustomPresets
      _disabledByDefault = source._disabledByDefault
      _icon = source._icon
      _entityCategory = source._entityCategory
      _visualCurrentTemperatureStep = source._visualCurrentTemperatureStep
      _supportsCurrentHumidity = source._supportsCurrentHumidity
      _supportsTargetHumidity = source._supportsTargetHumidity
      _visualMinHumidity = source._visualMinHumidity
      _visualMaxHumidity = source._visualMaxHumidity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._objectID) }()
        case 2: try { try decoder.decodeSingularFixed32Field(value: &_storage._key) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._uniqueID) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._supportsCurrentTemperature) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._supportsTwoPointTargetTemperature) }()
        case 7: try { try decoder.decodeRepeatedEnumField(value: &_storage._supportedModes) }()
        case 8: try { try decoder.decodeSingularFloatField(value: &_storage._visualMinTemperature) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._visualMaxTemperature) }()
        case 10: try { try decoder.decodeSingularFloatField(value: &_storage._visualTargetTemperatureStep) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._legacySupportsAway) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._supportsAction) }()
        case 13: try { try decoder.decodeRepeatedEnumField(value: &_storage._supportedFanModes) }()
        case 14: try { try decoder.decodeRepeatedEnumField(value: &_storage._supportedSwingModes) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._supportedCustomFanModes) }()
        case 16: try { try decoder.decodeRepeatedEnumField(value: &_storage._supportedPresets) }()
        case 17: try { try decoder.decodeRepeatedStringField(value: &_storage._supportedCustomPresets) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._disabledByDefault) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._icon) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._entityCategory) }()
        case 21: try { try decoder.decodeSingularFloatField(value: &_storage._visualCurrentTemperatureStep) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._supportsCurrentHumidity) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._supportsTargetHumidity) }()
        case 24: try { try decoder.decodeSingularFloatField(value: &_storage._visualMinHumidity) }()
        case 25: try { try decoder.decodeSingularFloatField(value: &_storage._visualMaxHumidity) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._objectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._objectID, fieldNumber: 1)
      }
      if _storage._key != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._key, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._uniqueID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uniqueID, fieldNumber: 4)
      }
      if _storage._supportsCurrentTemperature != false {
        try visitor.visitSingularBoolField(value: _storage._supportsCurrentTemperature, fieldNumber: 5)
      }
      if _storage._supportsTwoPointTargetTemperature != false {
        try visitor.visitSingularBoolField(value: _storage._supportsTwoPointTargetTemperature, fieldNumber: 6)
      }
      if !_storage._supportedModes.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._supportedModes, fieldNumber: 7)
      }
      if _storage._visualMinTemperature.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._visualMinTemperature, fieldNumber: 8)
      }
      if _storage._visualMaxTemperature.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._visualMaxTemperature, fieldNumber: 9)
      }
      if _storage._visualTargetTemperatureStep.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._visualTargetTemperatureStep, fieldNumber: 10)
      }
      if _storage._legacySupportsAway != false {
        try visitor.visitSingularBoolField(value: _storage._legacySupportsAway, fieldNumber: 11)
      }
      if _storage._supportsAction != false {
        try visitor.visitSingularBoolField(value: _storage._supportsAction, fieldNumber: 12)
      }
      if !_storage._supportedFanModes.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._supportedFanModes, fieldNumber: 13)
      }
      if !_storage._supportedSwingModes.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._supportedSwingModes, fieldNumber: 14)
      }
      if !_storage._supportedCustomFanModes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._supportedCustomFanModes, fieldNumber: 15)
      }
      if !_storage._supportedPresets.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._supportedPresets, fieldNumber: 16)
      }
      if !_storage._supportedCustomPresets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._supportedCustomPresets, fieldNumber: 17)
      }
      if _storage._disabledByDefault != false {
        try visitor.visitSingularBoolField(value: _storage._disabledByDefault, fieldNumber: 18)
      }
      if !_storage._icon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._icon, fieldNumber: 19)
      }
      if _storage._entityCategory != .none {
        try visitor.visitSingularEnumField(value: _storage._entityCategory, fieldNumber: 20)
      }
      if _storage._visualCurrentTemperatureStep.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._visualCurrentTemperatureStep, fieldNumber: 21)
      }
      if _storage._supportsCurrentHumidity != false {
        try visitor.visitSingularBoolField(value: _storage._supportsCurrentHumidity, fieldNumber: 22)
      }
      if _storage._supportsTargetHumidity != false {
        try visitor.visitSingularBoolField(value: _storage._supportsTargetHumidity, fieldNumber: 23)
      }
      if _storage._visualMinHumidity.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._visualMinHumidity, fieldNumber: 24)
      }
      if _storage._visualMaxHumidity.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._visualMaxHumidity, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesClimateResponse, rhs: ListEntitiesClimateResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._objectID != rhs_storage._objectID {return false}
        if _storage._key != rhs_storage._key {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._uniqueID != rhs_storage._uniqueID {return false}
        if _storage._supportsCurrentTemperature != rhs_storage._supportsCurrentTemperature {return false}
        if _storage._supportsTwoPointTargetTemperature != rhs_storage._supportsTwoPointTargetTemperature {return false}
        if _storage._supportedModes != rhs_storage._supportedModes {return false}
        if _storage._visualMinTemperature != rhs_storage._visualMinTemperature {return false}
        if _storage._visualMaxTemperature != rhs_storage._visualMaxTemperature {return false}
        if _storage._visualTargetTemperatureStep != rhs_storage._visualTargetTemperatureStep {return false}
        if _storage._legacySupportsAway != rhs_storage._legacySupportsAway {return false}
        if _storage._supportsAction != rhs_storage._supportsAction {return false}
        if _storage._supportedFanModes != rhs_storage._supportedFanModes {return false}
        if _storage._supportedSwingModes != rhs_storage._supportedSwingModes {return false}
        if _storage._supportedCustomFanModes != rhs_storage._supportedCustomFanModes {return false}
        if _storage._supportedPresets != rhs_storage._supportedPresets {return false}
        if _storage._supportedCustomPresets != rhs_storage._supportedCustomPresets {return false}
        if _storage._disabledByDefault != rhs_storage._disabledByDefault {return false}
        if _storage._icon != rhs_storage._icon {return false}
        if _storage._entityCategory != rhs_storage._entityCategory {return false}
        if _storage._visualCurrentTemperatureStep != rhs_storage._visualCurrentTemperatureStep {return false}
        if _storage._supportsCurrentHumidity != rhs_storage._supportsCurrentHumidity {return false}
        if _storage._supportsTargetHumidity != rhs_storage._supportsTargetHumidity {return false}
        if _storage._visualMinHumidity != rhs_storage._visualMinHumidity {return false}
        if _storage._visualMaxHumidity != rhs_storage._visualMaxHumidity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClimateStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClimateStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "mode"),
    3: .standard(proto: "current_temperature"),
    4: .standard(proto: "target_temperature"),
    5: .standard(proto: "target_temperature_low"),
    6: .standard(proto: "target_temperature_high"),
    7: .standard(proto: "unused_legacy_away"),
    8: .same(proto: "action"),
    9: .standard(proto: "fan_mode"),
    10: .standard(proto: "swing_mode"),
    11: .standard(proto: "custom_fan_mode"),
    12: .same(proto: "preset"),
    13: .standard(proto: "custom_preset"),
    14: .standard(proto: "current_humidity"),
    15: .standard(proto: "target_humidity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.currentTemperature) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.targetTemperature) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.targetTemperatureLow) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.targetTemperatureHigh) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.unusedLegacyAway) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.fanMode) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.swingMode) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.customFanMode) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.preset) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.customPreset) }()
      case 14: try { try decoder.decodeSingularFloatField(value: &self.currentHumidity) }()
      case 15: try { try decoder.decodeSingularFloatField(value: &self.targetHumidity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.mode != .off {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    if self.currentTemperature.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.currentTemperature, fieldNumber: 3)
    }
    if self.targetTemperature.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.targetTemperature, fieldNumber: 4)
    }
    if self.targetTemperatureLow.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.targetTemperatureLow, fieldNumber: 5)
    }
    if self.targetTemperatureHigh.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.targetTemperatureHigh, fieldNumber: 6)
    }
    if self.unusedLegacyAway != false {
      try visitor.visitSingularBoolField(value: self.unusedLegacyAway, fieldNumber: 7)
    }
    if self.action != .off {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 8)
    }
    if self.fanMode != .climateFanOn {
      try visitor.visitSingularEnumField(value: self.fanMode, fieldNumber: 9)
    }
    if self.swingMode != .climateSwingOff {
      try visitor.visitSingularEnumField(value: self.swingMode, fieldNumber: 10)
    }
    if !self.customFanMode.isEmpty {
      try visitor.visitSingularStringField(value: self.customFanMode, fieldNumber: 11)
    }
    if self.preset != .none {
      try visitor.visitSingularEnumField(value: self.preset, fieldNumber: 12)
    }
    if !self.customPreset.isEmpty {
      try visitor.visitSingularStringField(value: self.customPreset, fieldNumber: 13)
    }
    if self.currentHumidity.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.currentHumidity, fieldNumber: 14)
    }
    if self.targetHumidity.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.targetHumidity, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClimateStateResponse, rhs: ClimateStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.currentTemperature != rhs.currentTemperature {return false}
    if lhs.targetTemperature != rhs.targetTemperature {return false}
    if lhs.targetTemperatureLow != rhs.targetTemperatureLow {return false}
    if lhs.targetTemperatureHigh != rhs.targetTemperatureHigh {return false}
    if lhs.unusedLegacyAway != rhs.unusedLegacyAway {return false}
    if lhs.action != rhs.action {return false}
    if lhs.fanMode != rhs.fanMode {return false}
    if lhs.swingMode != rhs.swingMode {return false}
    if lhs.customFanMode != rhs.customFanMode {return false}
    if lhs.preset != rhs.preset {return false}
    if lhs.customPreset != rhs.customPreset {return false}
    if lhs.currentHumidity != rhs.currentHumidity {return false}
    if lhs.targetHumidity != rhs.targetHumidity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClimateCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClimateCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "has_mode"),
    3: .same(proto: "mode"),
    4: .standard(proto: "has_target_temperature"),
    5: .standard(proto: "target_temperature"),
    6: .standard(proto: "has_target_temperature_low"),
    7: .standard(proto: "target_temperature_low"),
    8: .standard(proto: "has_target_temperature_high"),
    9: .standard(proto: "target_temperature_high"),
    10: .standard(proto: "unused_has_legacy_away"),
    11: .standard(proto: "unused_legacy_away"),
    12: .standard(proto: "has_fan_mode"),
    13: .standard(proto: "fan_mode"),
    14: .standard(proto: "has_swing_mode"),
    15: .standard(proto: "swing_mode"),
    16: .standard(proto: "has_custom_fan_mode"),
    17: .standard(proto: "custom_fan_mode"),
    18: .standard(proto: "has_preset"),
    19: .same(proto: "preset"),
    20: .standard(proto: "has_custom_preset"),
    21: .standard(proto: "custom_preset"),
    22: .standard(proto: "has_target_humidity"),
    23: .standard(proto: "target_humidity"),
  ]

  fileprivate class _StorageClass {
    var _key: UInt32 = 0
    var _hasMode_p: Bool = false
    var _mode: ClimateMode = .off
    var _hasTargetTemperature_p: Bool = false
    var _targetTemperature: Float = 0
    var _hasTargetTemperatureLow_p: Bool = false
    var _targetTemperatureLow: Float = 0
    var _hasTargetTemperatureHigh_p: Bool = false
    var _targetTemperatureHigh: Float = 0
    var _unusedHasLegacyAway: Bool = false
    var _unusedLegacyAway: Bool = false
    var _hasFanMode_p: Bool = false
    var _fanMode: ClimateFanMode = .climateFanOn
    var _hasSwingMode_p: Bool = false
    var _swingMode: ClimateSwingMode = .climateSwingOff
    var _hasCustomFanMode_p: Bool = false
    var _customFanMode: String = String()
    var _hasPreset_p: Bool = false
    var _preset: ClimatePreset = .none
    var _hasCustomPreset_p: Bool = false
    var _customPreset: String = String()
    var _hasTargetHumidity_p: Bool = false
    var _targetHumidity: Float = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _key = source._key
      _hasMode_p = source._hasMode_p
      _mode = source._mode
      _hasTargetTemperature_p = source._hasTargetTemperature_p
      _targetTemperature = source._targetTemperature
      _hasTargetTemperatureLow_p = source._hasTargetTemperatureLow_p
      _targetTemperatureLow = source._targetTemperatureLow
      _hasTargetTemperatureHigh_p = source._hasTargetTemperatureHigh_p
      _targetTemperatureHigh = source._targetTemperatureHigh
      _unusedHasLegacyAway = source._unusedHasLegacyAway
      _unusedLegacyAway = source._unusedLegacyAway
      _hasFanMode_p = source._hasFanMode_p
      _fanMode = source._fanMode
      _hasSwingMode_p = source._hasSwingMode_p
      _swingMode = source._swingMode
      _hasCustomFanMode_p = source._hasCustomFanMode_p
      _customFanMode = source._customFanMode
      _hasPreset_p = source._hasPreset_p
      _preset = source._preset
      _hasCustomPreset_p = source._hasCustomPreset_p
      _customPreset = source._customPreset
      _hasTargetHumidity_p = source._hasTargetHumidity_p
      _targetHumidity = source._targetHumidity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed32Field(value: &_storage._key) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._hasMode_p) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._mode) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._hasTargetTemperature_p) }()
        case 5: try { try decoder.decodeSingularFloatField(value: &_storage._targetTemperature) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._hasTargetTemperatureLow_p) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._targetTemperatureLow) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._hasTargetTemperatureHigh_p) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._targetTemperatureHigh) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._unusedHasLegacyAway) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._unusedLegacyAway) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._hasFanMode_p) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._fanMode) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._hasSwingMode_p) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._swingMode) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._hasCustomFanMode_p) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._customFanMode) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._hasPreset_p) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._preset) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._hasCustomPreset_p) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._customPreset) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._hasTargetHumidity_p) }()
        case 23: try { try decoder.decodeSingularFloatField(value: &_storage._targetHumidity) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._key != 0 {
        try visitor.visitSingularFixed32Field(value: _storage._key, fieldNumber: 1)
      }
      if _storage._hasMode_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasMode_p, fieldNumber: 2)
      }
      if _storage._mode != .off {
        try visitor.visitSingularEnumField(value: _storage._mode, fieldNumber: 3)
      }
      if _storage._hasTargetTemperature_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasTargetTemperature_p, fieldNumber: 4)
      }
      if _storage._targetTemperature.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._targetTemperature, fieldNumber: 5)
      }
      if _storage._hasTargetTemperatureLow_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasTargetTemperatureLow_p, fieldNumber: 6)
      }
      if _storage._targetTemperatureLow.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._targetTemperatureLow, fieldNumber: 7)
      }
      if _storage._hasTargetTemperatureHigh_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasTargetTemperatureHigh_p, fieldNumber: 8)
      }
      if _storage._targetTemperatureHigh.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._targetTemperatureHigh, fieldNumber: 9)
      }
      if _storage._unusedHasLegacyAway != false {
        try visitor.visitSingularBoolField(value: _storage._unusedHasLegacyAway, fieldNumber: 10)
      }
      if _storage._unusedLegacyAway != false {
        try visitor.visitSingularBoolField(value: _storage._unusedLegacyAway, fieldNumber: 11)
      }
      if _storage._hasFanMode_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasFanMode_p, fieldNumber: 12)
      }
      if _storage._fanMode != .climateFanOn {
        try visitor.visitSingularEnumField(value: _storage._fanMode, fieldNumber: 13)
      }
      if _storage._hasSwingMode_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasSwingMode_p, fieldNumber: 14)
      }
      if _storage._swingMode != .climateSwingOff {
        try visitor.visitSingularEnumField(value: _storage._swingMode, fieldNumber: 15)
      }
      if _storage._hasCustomFanMode_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasCustomFanMode_p, fieldNumber: 16)
      }
      if !_storage._customFanMode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customFanMode, fieldNumber: 17)
      }
      if _storage._hasPreset_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasPreset_p, fieldNumber: 18)
      }
      if _storage._preset != .none {
        try visitor.visitSingularEnumField(value: _storage._preset, fieldNumber: 19)
      }
      if _storage._hasCustomPreset_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasCustomPreset_p, fieldNumber: 20)
      }
      if !_storage._customPreset.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customPreset, fieldNumber: 21)
      }
      if _storage._hasTargetHumidity_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasTargetHumidity_p, fieldNumber: 22)
      }
      if _storage._targetHumidity.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._targetHumidity, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClimateCommandRequest, rhs: ClimateCommandRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._key != rhs_storage._key {return false}
        if _storage._hasMode_p != rhs_storage._hasMode_p {return false}
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._hasTargetTemperature_p != rhs_storage._hasTargetTemperature_p {return false}
        if _storage._targetTemperature != rhs_storage._targetTemperature {return false}
        if _storage._hasTargetTemperatureLow_p != rhs_storage._hasTargetTemperatureLow_p {return false}
        if _storage._targetTemperatureLow != rhs_storage._targetTemperatureLow {return false}
        if _storage._hasTargetTemperatureHigh_p != rhs_storage._hasTargetTemperatureHigh_p {return false}
        if _storage._targetTemperatureHigh != rhs_storage._targetTemperatureHigh {return false}
        if _storage._unusedHasLegacyAway != rhs_storage._unusedHasLegacyAway {return false}
        if _storage._unusedLegacyAway != rhs_storage._unusedLegacyAway {return false}
        if _storage._hasFanMode_p != rhs_storage._hasFanMode_p {return false}
        if _storage._fanMode != rhs_storage._fanMode {return false}
        if _storage._hasSwingMode_p != rhs_storage._hasSwingMode_p {return false}
        if _storage._swingMode != rhs_storage._swingMode {return false}
        if _storage._hasCustomFanMode_p != rhs_storage._hasCustomFanMode_p {return false}
        if _storage._customFanMode != rhs_storage._customFanMode {return false}
        if _storage._hasPreset_p != rhs_storage._hasPreset_p {return false}
        if _storage._preset != rhs_storage._preset {return false}
        if _storage._hasCustomPreset_p != rhs_storage._hasCustomPreset_p {return false}
        if _storage._customPreset != rhs_storage._customPreset {return false}
        if _storage._hasTargetHumidity_p != rhs_storage._hasTargetHumidity_p {return false}
        if _storage._targetHumidity != rhs_storage._targetHumidity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesNumberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesNumberResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "min_value"),
    7: .standard(proto: "max_value"),
    8: .same(proto: "step"),
    9: .standard(proto: "disabled_by_default"),
    10: .standard(proto: "entity_category"),
    11: .standard(proto: "unit_of_measurement"),
    12: .same(proto: "mode"),
    13: .standard(proto: "device_class"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.minValue) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.maxValue) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.step) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.unitOfMeasurement) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.deviceClass) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.minValue.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.minValue, fieldNumber: 6)
    }
    if self.maxValue.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.maxValue, fieldNumber: 7)
    }
    if self.step.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.step, fieldNumber: 8)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 9)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 10)
    }
    if !self.unitOfMeasurement.isEmpty {
      try visitor.visitSingularStringField(value: self.unitOfMeasurement, fieldNumber: 11)
    }
    if self.mode != .auto {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 12)
    }
    if !self.deviceClass.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceClass, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesNumberResponse, rhs: ListEntitiesNumberResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.minValue != rhs.minValue {return false}
    if lhs.maxValue != rhs.maxValue {return false}
    if lhs.step != rhs.step {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.unitOfMeasurement != rhs.unitOfMeasurement {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NumberStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NumberStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
    3: .standard(proto: "missing_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.missingState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.state, fieldNumber: 2)
    }
    if self.missingState != false {
      try visitor.visitSingularBoolField(value: self.missingState, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NumberStateResponse, rhs: NumberStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.missingState != rhs.missingState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NumberCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NumberCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NumberCommandRequest, rhs: NumberCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesSelectResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesSelectResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .same(proto: "options"),
    7: .standard(proto: "disabled_by_default"),
    8: .standard(proto: "entity_category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.options) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedStringField(value: self.options, fieldNumber: 6)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 7)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesSelectResponse, rhs: ListEntitiesSelectResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.options != rhs.options {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SelectStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SelectStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
    3: .standard(proto: "missing_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.missingState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 2)
    }
    if self.missingState != false {
      try visitor.visitSingularBoolField(value: self.missingState, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SelectStateResponse, rhs: SelectStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.missingState != rhs.missingState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SelectCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SelectCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SelectCommandRequest, rhs: SelectCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesSirenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesSirenResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .same(proto: "tones"),
    8: .standard(proto: "supports_duration"),
    9: .standard(proto: "supports_volume"),
    10: .standard(proto: "entity_category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.tones) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.supportsDuration) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.supportsVolume) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if !self.tones.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tones, fieldNumber: 7)
    }
    if self.supportsDuration != false {
      try visitor.visitSingularBoolField(value: self.supportsDuration, fieldNumber: 8)
    }
    if self.supportsVolume != false {
      try visitor.visitSingularBoolField(value: self.supportsVolume, fieldNumber: 9)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesSirenResponse, rhs: ListEntitiesSirenResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.tones != rhs.tones {return false}
    if lhs.supportsDuration != rhs.supportsDuration {return false}
    if lhs.supportsVolume != rhs.supportsVolume {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SirenStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SirenStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SirenStateResponse, rhs: SirenStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SirenCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SirenCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "has_state"),
    3: .same(proto: "state"),
    4: .standard(proto: "has_tone"),
    5: .same(proto: "tone"),
    6: .standard(proto: "has_duration"),
    7: .same(proto: "duration"),
    8: .standard(proto: "has_volume"),
    9: .same(proto: "volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasState_p) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.hasTone_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tone) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.hasDuration_p) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.duration) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hasVolume_p) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.volume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.hasState_p != false {
      try visitor.visitSingularBoolField(value: self.hasState_p, fieldNumber: 2)
    }
    if self.state != false {
      try visitor.visitSingularBoolField(value: self.state, fieldNumber: 3)
    }
    if self.hasTone_p != false {
      try visitor.visitSingularBoolField(value: self.hasTone_p, fieldNumber: 4)
    }
    if !self.tone.isEmpty {
      try visitor.visitSingularStringField(value: self.tone, fieldNumber: 5)
    }
    if self.hasDuration_p != false {
      try visitor.visitSingularBoolField(value: self.hasDuration_p, fieldNumber: 6)
    }
    if self.duration != 0 {
      try visitor.visitSingularUInt32Field(value: self.duration, fieldNumber: 7)
    }
    if self.hasVolume_p != false {
      try visitor.visitSingularBoolField(value: self.hasVolume_p, fieldNumber: 8)
    }
    if self.volume.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.volume, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SirenCommandRequest, rhs: SirenCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.hasState_p != rhs.hasState_p {return false}
    if lhs.state != rhs.state {return false}
    if lhs.hasTone_p != rhs.hasTone_p {return false}
    if lhs.tone != rhs.tone {return false}
    if lhs.hasDuration_p != rhs.hasDuration_p {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.hasVolume_p != rhs.hasVolume_p {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesLockResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesLockResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
    8: .standard(proto: "assumed_state"),
    9: .standard(proto: "supports_open"),
    10: .standard(proto: "requires_code"),
    11: .standard(proto: "code_format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.assumedState) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.supportsOpen) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.requiresCode) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.codeFormat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    if self.assumedState != false {
      try visitor.visitSingularBoolField(value: self.assumedState, fieldNumber: 8)
    }
    if self.supportsOpen != false {
      try visitor.visitSingularBoolField(value: self.supportsOpen, fieldNumber: 9)
    }
    if self.requiresCode != false {
      try visitor.visitSingularBoolField(value: self.requiresCode, fieldNumber: 10)
    }
    if !self.codeFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.codeFormat, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesLockResponse, rhs: ListEntitiesLockResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.assumedState != rhs.assumedState {return false}
    if lhs.supportsOpen != rhs.supportsOpen {return false}
    if lhs.requiresCode != rhs.requiresCode {return false}
    if lhs.codeFormat != rhs.codeFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LockStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LockStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state != .none {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LockStateResponse, rhs: LockStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LockCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LockCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "command"),
    3: .standard(proto: "has_code"),
    4: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hasCode_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.command != .lockUnlock {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 2)
    }
    if self.hasCode_p != false {
      try visitor.visitSingularBoolField(value: self.hasCode_p, fieldNumber: 3)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LockCommandRequest, rhs: LockCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.command != rhs.command {return false}
    if lhs.hasCode_p != rhs.hasCode_p {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesButtonResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesButtonResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
    8: .standard(proto: "device_class"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.deviceClass) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    if !self.deviceClass.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceClass, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesButtonResponse, rhs: ListEntitiesButtonResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ButtonCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ButtonCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ButtonCommandRequest, rhs: ButtonCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MediaPlayerSupportedFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MediaPlayerSupportedFormat"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .standard(proto: "sample_rate"),
    3: .standard(proto: "num_channels"),
    4: .same(proto: "purpose"),
    5: .standard(proto: "sample_bytes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sampleRate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.numChannels) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.purpose) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.sampleBytes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 1)
    }
    if self.sampleRate != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleRate, fieldNumber: 2)
    }
    if self.numChannels != 0 {
      try visitor.visitSingularUInt32Field(value: self.numChannels, fieldNumber: 3)
    }
    if self.purpose != .default {
      try visitor.visitSingularEnumField(value: self.purpose, fieldNumber: 4)
    }
    if self.sampleBytes != 0 {
      try visitor.visitSingularUInt32Field(value: self.sampleBytes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MediaPlayerSupportedFormat, rhs: MediaPlayerSupportedFormat) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.sampleRate != rhs.sampleRate {return false}
    if lhs.numChannels != rhs.numChannels {return false}
    if lhs.purpose != rhs.purpose {return false}
    if lhs.sampleBytes != rhs.sampleBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesMediaPlayerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesMediaPlayerResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
    8: .standard(proto: "supports_pause"),
    9: .standard(proto: "supported_formats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.supportsPause) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.supportedFormats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    if self.supportsPause != false {
      try visitor.visitSingularBoolField(value: self.supportsPause, fieldNumber: 8)
    }
    if !self.supportedFormats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supportedFormats, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesMediaPlayerResponse, rhs: ListEntitiesMediaPlayerResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.supportsPause != rhs.supportsPause {return false}
    if lhs.supportedFormats != rhs.supportedFormats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MediaPlayerStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MediaPlayerStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
    3: .same(proto: "volume"),
    4: .same(proto: "muted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.volume) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.muted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state != .none {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    if self.volume.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.volume, fieldNumber: 3)
    }
    if self.muted != false {
      try visitor.visitSingularBoolField(value: self.muted, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MediaPlayerStateResponse, rhs: MediaPlayerStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.muted != rhs.muted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MediaPlayerCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MediaPlayerCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "has_command"),
    3: .same(proto: "command"),
    4: .standard(proto: "has_volume"),
    5: .same(proto: "volume"),
    6: .standard(proto: "has_media_url"),
    7: .standard(proto: "media_url"),
    8: .standard(proto: "has_announcement"),
    9: .same(proto: "announcement"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasCommand_p) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.hasVolume_p) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.volume) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.hasMediaURL_p) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.mediaURL) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hasAnnouncement_p) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.announcement) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.hasCommand_p != false {
      try visitor.visitSingularBoolField(value: self.hasCommand_p, fieldNumber: 2)
    }
    if self.command != .play {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 3)
    }
    if self.hasVolume_p != false {
      try visitor.visitSingularBoolField(value: self.hasVolume_p, fieldNumber: 4)
    }
    if self.volume.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.volume, fieldNumber: 5)
    }
    if self.hasMediaURL_p != false {
      try visitor.visitSingularBoolField(value: self.hasMediaURL_p, fieldNumber: 6)
    }
    if !self.mediaURL.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaURL, fieldNumber: 7)
    }
    if self.hasAnnouncement_p != false {
      try visitor.visitSingularBoolField(value: self.hasAnnouncement_p, fieldNumber: 8)
    }
    if self.announcement != false {
      try visitor.visitSingularBoolField(value: self.announcement, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MediaPlayerCommandRequest, rhs: MediaPlayerCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.hasCommand_p != rhs.hasCommand_p {return false}
    if lhs.command != rhs.command {return false}
    if lhs.hasVolume_p != rhs.hasVolume_p {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.hasMediaURL_p != rhs.hasMediaURL_p {return false}
    if lhs.mediaURL != rhs.mediaURL {return false}
    if lhs.hasAnnouncement_p != rhs.hasAnnouncement_p {return false}
    if lhs.announcement != rhs.announcement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeBluetoothLEAdvertisementsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubscribeBluetoothLEAdvertisementsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubscribeBluetoothLEAdvertisementsRequest, rhs: SubscribeBluetoothLEAdvertisementsRequest) -> Bool {
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothServiceData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothServiceData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "legacy_data"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.legacyData) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.legacyData.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.legacyData, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothServiceData, rhs: BluetoothServiceData) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.legacyData != rhs.legacyData {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothLEAdvertisementResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothLEAdvertisementResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "name"),
    3: .same(proto: "rssi"),
    4: .standard(proto: "service_uuids"),
    5: .standard(proto: "service_data"),
    6: .standard(proto: "manufacturer_data"),
    7: .standard(proto: "address_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularSInt32Field(value: &self.rssi) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.serviceUuids) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.serviceData) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.manufacturerData) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.addressType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 2)
    }
    if self.rssi != 0 {
      try visitor.visitSingularSInt32Field(value: self.rssi, fieldNumber: 3)
    }
    if !self.serviceUuids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serviceUuids, fieldNumber: 4)
    }
    if !self.serviceData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceData, fieldNumber: 5)
    }
    if !self.manufacturerData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.manufacturerData, fieldNumber: 6)
    }
    if self.addressType != 0 {
      try visitor.visitSingularUInt32Field(value: self.addressType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothLEAdvertisementResponse, rhs: BluetoothLEAdvertisementResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.name != rhs.name {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.serviceUuids != rhs.serviceUuids {return false}
    if lhs.serviceData != rhs.serviceData {return false}
    if lhs.manufacturerData != rhs.manufacturerData {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothLERawAdvertisement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothLERawAdvertisement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "rssi"),
    3: .standard(proto: "address_type"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularSInt32Field(value: &self.rssi) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.addressType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.rssi != 0 {
      try visitor.visitSingularSInt32Field(value: self.rssi, fieldNumber: 2)
    }
    if self.addressType != 0 {
      try visitor.visitSingularUInt32Field(value: self.addressType, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothLERawAdvertisement, rhs: BluetoothLERawAdvertisement) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.rssi != rhs.rssi {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothLERawAdvertisementsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothLERawAdvertisementsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "advertisements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.advertisements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.advertisements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.advertisements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothLERawAdvertisementsResponse, rhs: BluetoothLERawAdvertisementsResponse) -> Bool {
    if lhs.advertisements != rhs.advertisements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothDeviceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "request_type"),
    3: .standard(proto: "has_address_type"),
    4: .standard(proto: "address_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.requestType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hasAddressType_p) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.addressType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.requestType != .connect {
      try visitor.visitSingularEnumField(value: self.requestType, fieldNumber: 2)
    }
    if self.hasAddressType_p != false {
      try visitor.visitSingularBoolField(value: self.hasAddressType_p, fieldNumber: 3)
    }
    if self.addressType != 0 {
      try visitor.visitSingularUInt32Field(value: self.addressType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothDeviceRequest, rhs: BluetoothDeviceRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.requestType != rhs.requestType {return false}
    if lhs.hasAddressType_p != rhs.hasAddressType_p {return false}
    if lhs.addressType != rhs.addressType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothDeviceConnectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothDeviceConnectionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "connected"),
    3: .same(proto: "mtu"),
    4: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.connected) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.mtu) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.connected != false {
      try visitor.visitSingularBoolField(value: self.connected, fieldNumber: 2)
    }
    if self.mtu != 0 {
      try visitor.visitSingularUInt32Field(value: self.mtu, fieldNumber: 3)
    }
    if self.error != 0 {
      try visitor.visitSingularInt32Field(value: self.error, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothDeviceConnectionResponse, rhs: BluetoothDeviceConnectionResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.connected != rhs.connected {return false}
    if lhs.mtu != rhs.mtu {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTGetServicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTGetServicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTGetServicesRequest, rhs: BluetoothGATTGetServicesRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "handle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.uuid, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTDescriptor, rhs: BluetoothGATTDescriptor) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTCharacteristic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTCharacteristic"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "handle"),
    3: .same(proto: "properties"),
    4: .same(proto: "descriptors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.properties) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.descriptors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.uuid, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    if self.properties != 0 {
      try visitor.visitSingularUInt32Field(value: self.properties, fieldNumber: 3)
    }
    if !self.descriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.descriptors, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTCharacteristic, rhs: BluetoothGATTCharacteristic) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.descriptors != rhs.descriptors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTService"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "handle"),
    3: .same(proto: "characteristics"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.characteristics) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.uuid, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    if !self.characteristics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.characteristics, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTService, rhs: BluetoothGATTService) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.characteristics != rhs.characteristics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTGetServicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTGetServicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTGetServicesResponse, rhs: BluetoothGATTGetServicesResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTGetServicesDoneResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTGetServicesDoneResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTGetServicesDoneResponse, rhs: BluetoothGATTGetServicesDoneResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTReadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "handle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTReadRequest, rhs: BluetoothGATTReadRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTReadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTReadResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "handle"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTReadResponse, rhs: BluetoothGATTReadResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTWriteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTWriteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "handle"),
    3: .same(proto: "response"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.response) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    if self.response != false {
      try visitor.visitSingularBoolField(value: self.response, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTWriteRequest, rhs: BluetoothGATTWriteRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.response != rhs.response {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTReadDescriptorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTReadDescriptorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "handle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTReadDescriptorRequest, rhs: BluetoothGATTReadDescriptorRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTWriteDescriptorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTWriteDescriptorRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "handle"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTWriteDescriptorRequest, rhs: BluetoothGATTWriteDescriptorRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTNotifyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTNotifyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "handle"),
    3: .same(proto: "enable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    if self.enable != false {
      try visitor.visitSingularBoolField(value: self.enable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTNotifyRequest, rhs: BluetoothGATTNotifyRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTNotifyDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTNotifyDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "handle"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTNotifyDataResponse, rhs: BluetoothGATTNotifyDataResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeBluetoothConnectionsFreeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubscribeBluetoothConnectionsFreeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubscribeBluetoothConnectionsFreeRequest, rhs: SubscribeBluetoothConnectionsFreeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothConnectionsFreeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothConnectionsFreeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "free"),
    2: .same(proto: "limit"),
    3: .same(proto: "allocated"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.free) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.limit) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.allocated) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.free != 0 {
      try visitor.visitSingularUInt32Field(value: self.free, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularUInt32Field(value: self.limit, fieldNumber: 2)
    }
    if !self.allocated.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.allocated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothConnectionsFreeResponse, rhs: BluetoothConnectionsFreeResponse) -> Bool {
    if lhs.free != rhs.free {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.allocated != rhs.allocated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTErrorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "handle"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    if self.error != 0 {
      try visitor.visitSingularInt32Field(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTErrorResponse, rhs: BluetoothGATTErrorResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTWriteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTWriteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "handle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTWriteResponse, rhs: BluetoothGATTWriteResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothGATTNotifyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothGATTNotifyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "handle"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.handle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.handle != 0 {
      try visitor.visitSingularUInt32Field(value: self.handle, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothGATTNotifyResponse, rhs: BluetoothGATTNotifyResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.handle != rhs.handle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothDevicePairingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothDevicePairingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "paired"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.paired) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.paired != false {
      try visitor.visitSingularBoolField(value: self.paired, fieldNumber: 2)
    }
    if self.error != 0 {
      try visitor.visitSingularInt32Field(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothDevicePairingResponse, rhs: BluetoothDevicePairingResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.paired != rhs.paired {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothDeviceUnpairingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothDeviceUnpairingResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if self.error != 0 {
      try visitor.visitSingularInt32Field(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothDeviceUnpairingResponse, rhs: BluetoothDeviceUnpairingResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnsubscribeBluetoothLEAdvertisementsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UnsubscribeBluetoothLEAdvertisementsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UnsubscribeBluetoothLEAdvertisementsRequest, rhs: UnsubscribeBluetoothLEAdvertisementsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothDeviceClearCacheResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothDeviceClearCacheResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "success"),
    3: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.address) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.address != 0 {
      try visitor.visitSingularUInt64Field(value: self.address, fieldNumber: 1)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    if self.error != 0 {
      try visitor.visitSingularInt32Field(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothDeviceClearCacheResponse, rhs: BluetoothDeviceClearCacheResponse) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.success != rhs.success {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothScannerStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothScannerStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .idle {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if self.mode != .passive {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothScannerStateResponse, rhs: BluetoothScannerStateResponse) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BluetoothScannerSetModeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BluetoothScannerSetModeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .passive {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BluetoothScannerSetModeRequest, rhs: BluetoothScannerSetModeRequest) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubscribeVoiceAssistantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubscribeVoiceAssistantRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscribe"),
    2: .same(proto: "flags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.subscribe) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.subscribe != false {
      try visitor.visitSingularBoolField(value: self.subscribe, fieldNumber: 1)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubscribeVoiceAssistantRequest, rhs: SubscribeVoiceAssistantRequest) -> Bool {
    if lhs.subscribe != rhs.subscribe {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantAudioSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantAudioSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "noise_suppression_level"),
    2: .standard(proto: "auto_gain"),
    3: .standard(proto: "volume_multiplier"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.noiseSuppressionLevel) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.autoGain) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.volumeMultiplier) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.noiseSuppressionLevel != 0 {
      try visitor.visitSingularUInt32Field(value: self.noiseSuppressionLevel, fieldNumber: 1)
    }
    if self.autoGain != 0 {
      try visitor.visitSingularUInt32Field(value: self.autoGain, fieldNumber: 2)
    }
    if self.volumeMultiplier.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.volumeMultiplier, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantAudioSettings, rhs: VoiceAssistantAudioSettings) -> Bool {
    if lhs.noiseSuppressionLevel != rhs.noiseSuppressionLevel {return false}
    if lhs.autoGain != rhs.autoGain {return false}
    if lhs.volumeMultiplier != rhs.volumeMultiplier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .standard(proto: "conversation_id"),
    3: .same(proto: "flags"),
    4: .standard(proto: "audio_settings"),
    5: .standard(proto: "wake_word_phrase"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.start) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._audioSettings) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.wakeWordPhrase) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.start != false {
      try visitor.visitSingularBoolField(value: self.start, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 3)
    }
    try { if let v = self._audioSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.wakeWordPhrase.isEmpty {
      try visitor.visitSingularStringField(value: self.wakeWordPhrase, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantRequest, rhs: VoiceAssistantRequest) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs._audioSettings != rhs._audioSettings {return false}
    if lhs.wakeWordPhrase != rhs.wakeWordPhrase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
    2: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 1)
    }
    if self.error != false {
      try visitor.visitSingularBoolField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantResponse, rhs: VoiceAssistantResponse) -> Bool {
    if lhs.port != rhs.port {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantEventData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantEventData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantEventData, rhs: VoiceAssistantEventData) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantEventResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_type"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventType != .voiceAssistantError {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantEventResponse, rhs: VoiceAssistantEventResponse) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantAudio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.end) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if self.end != false {
      try visitor.visitSingularBoolField(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantAudio, rhs: VoiceAssistantAudio) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantTimerEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantTimerEventResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_type"),
    2: .standard(proto: "timer_id"),
    3: .same(proto: "name"),
    4: .standard(proto: "total_seconds"),
    5: .standard(proto: "seconds_left"),
    6: .standard(proto: "is_active"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.timerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.totalSeconds) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.secondsLeft) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isActive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventType != .voiceAssistantTimerStarted {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 1)
    }
    if !self.timerID.isEmpty {
      try visitor.visitSingularStringField(value: self.timerID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.totalSeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSeconds, fieldNumber: 4)
    }
    if self.secondsLeft != 0 {
      try visitor.visitSingularUInt32Field(value: self.secondsLeft, fieldNumber: 5)
    }
    if self.isActive != false {
      try visitor.visitSingularBoolField(value: self.isActive, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantTimerEventResponse, rhs: VoiceAssistantTimerEventResponse) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.timerID != rhs.timerID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.totalSeconds != rhs.totalSeconds {return false}
    if lhs.secondsLeft != rhs.secondsLeft {return false}
    if lhs.isActive != rhs.isActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantAnnounceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantAnnounceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "media_id"),
    2: .same(proto: "text"),
    3: .standard(proto: "preannounce_media_id"),
    4: .standard(proto: "start_conversation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.preannounceMediaID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.startConversation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaID, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if !self.preannounceMediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.preannounceMediaID, fieldNumber: 3)
    }
    if self.startConversation != false {
      try visitor.visitSingularBoolField(value: self.startConversation, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantAnnounceRequest, rhs: VoiceAssistantAnnounceRequest) -> Bool {
    if lhs.mediaID != rhs.mediaID {return false}
    if lhs.text != rhs.text {return false}
    if lhs.preannounceMediaID != rhs.preannounceMediaID {return false}
    if lhs.startConversation != rhs.startConversation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantAnnounceFinished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantAnnounceFinished"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantAnnounceFinished, rhs: VoiceAssistantAnnounceFinished) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantWakeWord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantWakeWord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "wake_word"),
    3: .standard(proto: "trained_languages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.wakeWord) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.trainedLanguages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.wakeWord.isEmpty {
      try visitor.visitSingularStringField(value: self.wakeWord, fieldNumber: 2)
    }
    if !self.trainedLanguages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.trainedLanguages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantWakeWord, rhs: VoiceAssistantWakeWord) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.wakeWord != rhs.wakeWord {return false}
    if lhs.trainedLanguages != rhs.trainedLanguages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantConfigurationRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantConfigurationRequest, rhs: VoiceAssistantConfigurationRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantConfigurationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantConfigurationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_wake_words"),
    2: .standard(proto: "active_wake_words"),
    3: .standard(proto: "max_active_wake_words"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.availableWakeWords) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.activeWakeWords) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxActiveWakeWords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.availableWakeWords.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availableWakeWords, fieldNumber: 1)
    }
    if !self.activeWakeWords.isEmpty {
      try visitor.visitRepeatedStringField(value: self.activeWakeWords, fieldNumber: 2)
    }
    if self.maxActiveWakeWords != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxActiveWakeWords, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantConfigurationResponse, rhs: VoiceAssistantConfigurationResponse) -> Bool {
    if lhs.availableWakeWords != rhs.availableWakeWords {return false}
    if lhs.activeWakeWords != rhs.activeWakeWords {return false}
    if lhs.maxActiveWakeWords != rhs.maxActiveWakeWords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VoiceAssistantSetConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VoiceAssistantSetConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_wake_words"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.activeWakeWords) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.activeWakeWords.isEmpty {
      try visitor.visitRepeatedStringField(value: self.activeWakeWords, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VoiceAssistantSetConfiguration, rhs: VoiceAssistantSetConfiguration) -> Bool {
    if lhs.activeWakeWords != rhs.activeWakeWords {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesAlarmControlPanelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesAlarmControlPanelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
    8: .standard(proto: "supported_features"),
    9: .standard(proto: "requires_code"),
    10: .standard(proto: "requires_code_to_arm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.supportedFeatures) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.requiresCode) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.requiresCodeToArm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    if self.supportedFeatures != 0 {
      try visitor.visitSingularUInt32Field(value: self.supportedFeatures, fieldNumber: 8)
    }
    if self.requiresCode != false {
      try visitor.visitSingularBoolField(value: self.requiresCode, fieldNumber: 9)
    }
    if self.requiresCodeToArm != false {
      try visitor.visitSingularBoolField(value: self.requiresCodeToArm, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesAlarmControlPanelResponse, rhs: ListEntitiesAlarmControlPanelResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.supportedFeatures != rhs.supportedFeatures {return false}
    if lhs.requiresCode != rhs.requiresCode {return false}
    if lhs.requiresCodeToArm != rhs.requiresCodeToArm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AlarmControlPanelStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AlarmControlPanelStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.state != .alarmStateDisarmed {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AlarmControlPanelStateResponse, rhs: AlarmControlPanelStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AlarmControlPanelCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AlarmControlPanelCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "command"),
    3: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.command != .alarmControlPanelDisarm {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 2)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AlarmControlPanelCommandRequest, rhs: AlarmControlPanelCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.command != rhs.command {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesTextResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
    8: .standard(proto: "min_length"),
    9: .standard(proto: "max_length"),
    10: .same(proto: "pattern"),
    11: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.minLength) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.maxLength) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.pattern) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    if self.minLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.minLength, fieldNumber: 8)
    }
    if self.maxLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxLength, fieldNumber: 9)
    }
    if !self.pattern.isEmpty {
      try visitor.visitSingularStringField(value: self.pattern, fieldNumber: 10)
    }
    if self.mode != .text {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesTextResponse, rhs: ListEntitiesTextResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.minLength != rhs.minLength {return false}
    if lhs.maxLength != rhs.maxLength {return false}
    if lhs.pattern != rhs.pattern {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TextStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TextStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
    3: .standard(proto: "missing_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.missingState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 2)
    }
    if self.missingState != false {
      try visitor.visitSingularBoolField(value: self.missingState, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TextStateResponse, rhs: TextStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.missingState != rhs.missingState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TextCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TextCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TextCommandRequest, rhs: TextCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesDateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesDateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesDateResponse, rhs: ListEntitiesDateResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DateStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DateStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "missing_state"),
    3: .same(proto: "year"),
    4: .same(proto: "month"),
    5: .same(proto: "day"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.missingState) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.day) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.missingState != false {
      try visitor.visitSingularBoolField(value: self.missingState, fieldNumber: 2)
    }
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 3)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 4)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DateStateResponse, rhs: DateStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.missingState != rhs.missingState {return false}
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DateCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DateCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "year"),
    3: .same(proto: "month"),
    4: .same(proto: "day"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.day) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 2)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 3)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DateCommandRequest, rhs: DateCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesTimeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesTimeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesTimeResponse, rhs: ListEntitiesTimeResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TimeStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TimeStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "missing_state"),
    3: .same(proto: "hour"),
    4: .same(proto: "minute"),
    5: .same(proto: "second"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.missingState) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.hour) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.minute) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.second) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.missingState != false {
      try visitor.visitSingularBoolField(value: self.missingState, fieldNumber: 2)
    }
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 3)
    }
    if self.minute != 0 {
      try visitor.visitSingularUInt32Field(value: self.minute, fieldNumber: 4)
    }
    if self.second != 0 {
      try visitor.visitSingularUInt32Field(value: self.second, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TimeStateResponse, rhs: TimeStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.missingState != rhs.missingState {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.second != rhs.second {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TimeCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TimeCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "hour"),
    3: .same(proto: "minute"),
    4: .same(proto: "second"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.hour) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.minute) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.second) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 2)
    }
    if self.minute != 0 {
      try visitor.visitSingularUInt32Field(value: self.minute, fieldNumber: 3)
    }
    if self.second != 0 {
      try visitor.visitSingularUInt32Field(value: self.second, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TimeCommandRequest, rhs: TimeCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.second != rhs.second {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesEventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesEventResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
    8: .standard(proto: "device_class"),
    9: .standard(proto: "event_types"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.deviceClass) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.eventTypes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    if !self.deviceClass.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceClass, fieldNumber: 8)
    }
    if !self.eventTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.eventTypes, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesEventResponse, rhs: ListEntitiesEventResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.eventTypes != rhs.eventTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension EventResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "EventResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "event_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.eventType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if !self.eventType.isEmpty {
      try visitor.visitSingularStringField(value: self.eventType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: EventResponse, rhs: EventResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesValveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesValveResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
    8: .standard(proto: "device_class"),
    9: .standard(proto: "assumed_state"),
    10: .standard(proto: "supports_position"),
    11: .standard(proto: "supports_stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.deviceClass) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.assumedState) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.supportsPosition) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.supportsStop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    if !self.deviceClass.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceClass, fieldNumber: 8)
    }
    if self.assumedState != false {
      try visitor.visitSingularBoolField(value: self.assumedState, fieldNumber: 9)
    }
    if self.supportsPosition != false {
      try visitor.visitSingularBoolField(value: self.supportsPosition, fieldNumber: 10)
    }
    if self.supportsStop != false {
      try visitor.visitSingularBoolField(value: self.supportsStop, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesValveResponse, rhs: ListEntitiesValveResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.assumedState != rhs.assumedState {return false}
    if lhs.supportsPosition != rhs.supportsPosition {return false}
    if lhs.supportsStop != rhs.supportsStop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ValveStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ValveStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "position"),
    3: .standard(proto: "current_operation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.position) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.currentOperation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.position.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.position, fieldNumber: 2)
    }
    if self.currentOperation != .idle {
      try visitor.visitSingularEnumField(value: self.currentOperation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ValveStateResponse, rhs: ValveStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.position != rhs.position {return false}
    if lhs.currentOperation != rhs.currentOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ValveCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ValveCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "has_position"),
    3: .same(proto: "position"),
    4: .same(proto: "stop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasPosition_p) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.position) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.stop) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.hasPosition_p != false {
      try visitor.visitSingularBoolField(value: self.hasPosition_p, fieldNumber: 2)
    }
    if self.position.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.position, fieldNumber: 3)
    }
    if self.stop != false {
      try visitor.visitSingularBoolField(value: self.stop, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ValveCommandRequest, rhs: ValveCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.hasPosition_p != rhs.hasPosition_p {return false}
    if lhs.position != rhs.position {return false}
    if lhs.stop != rhs.stop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesDateTimeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesDateTimeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesDateTimeResponse, rhs: ListEntitiesDateTimeResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DateTimeStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DateTimeStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "missing_state"),
    3: .standard(proto: "epoch_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.missingState) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self.epochSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.missingState != false {
      try visitor.visitSingularBoolField(value: self.missingState, fieldNumber: 2)
    }
    if self.epochSeconds != 0 {
      try visitor.visitSingularFixed32Field(value: self.epochSeconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DateTimeStateResponse, rhs: DateTimeStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.missingState != rhs.missingState {return false}
    if lhs.epochSeconds != rhs.epochSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DateTimeCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DateTimeCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "epoch_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.epochSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.epochSeconds != 0 {
      try visitor.visitSingularFixed32Field(value: self.epochSeconds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DateTimeCommandRequest, rhs: DateTimeCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.epochSeconds != rhs.epochSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListEntitiesUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListEntitiesUpdateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "key"),
    3: .same(proto: "name"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "icon"),
    6: .standard(proto: "disabled_by_default"),
    7: .standard(proto: "entity_category"),
    8: .standard(proto: "device_class"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.objectID) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.icon) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabledByDefault) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.entityCategory) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.deviceClass) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectID.isEmpty {
      try visitor.visitSingularStringField(value: self.objectID, fieldNumber: 1)
    }
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularStringField(value: self.icon, fieldNumber: 5)
    }
    if self.disabledByDefault != false {
      try visitor.visitSingularBoolField(value: self.disabledByDefault, fieldNumber: 6)
    }
    if self.entityCategory != .none {
      try visitor.visitSingularEnumField(value: self.entityCategory, fieldNumber: 7)
    }
    if !self.deviceClass.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceClass, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListEntitiesUpdateResponse, rhs: ListEntitiesUpdateResponse) -> Bool {
    if lhs.objectID != rhs.objectID {return false}
    if lhs.key != rhs.key {return false}
    if lhs.name != rhs.name {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.disabledByDefault != rhs.disabledByDefault {return false}
    if lhs.entityCategory != rhs.entityCategory {return false}
    if lhs.deviceClass != rhs.deviceClass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateStateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "missing_state"),
    3: .standard(proto: "in_progress"),
    4: .standard(proto: "has_progress"),
    5: .same(proto: "progress"),
    6: .standard(proto: "current_version"),
    7: .standard(proto: "latest_version"),
    8: .same(proto: "title"),
    9: .standard(proto: "release_summary"),
    10: .standard(proto: "release_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.missingState) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.inProgress) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.hasProgress_p) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.progress) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.currentVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.latestVersion) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.releaseSummary) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.releaseURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.missingState != false {
      try visitor.visitSingularBoolField(value: self.missingState, fieldNumber: 2)
    }
    if self.inProgress != false {
      try visitor.visitSingularBoolField(value: self.inProgress, fieldNumber: 3)
    }
    if self.hasProgress_p != false {
      try visitor.visitSingularBoolField(value: self.hasProgress_p, fieldNumber: 4)
    }
    if self.progress.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.progress, fieldNumber: 5)
    }
    if !self.currentVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.currentVersion, fieldNumber: 6)
    }
    if !self.latestVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.latestVersion, fieldNumber: 7)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 8)
    }
    if !self.releaseSummary.isEmpty {
      try visitor.visitSingularStringField(value: self.releaseSummary, fieldNumber: 9)
    }
    if !self.releaseURL.isEmpty {
      try visitor.visitSingularStringField(value: self.releaseURL, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateStateResponse, rhs: UpdateStateResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.missingState != rhs.missingState {return false}
    if lhs.inProgress != rhs.inProgress {return false}
    if lhs.hasProgress_p != rhs.hasProgress_p {return false}
    if lhs.progress != rhs.progress {return false}
    if lhs.currentVersion != rhs.currentVersion {return false}
    if lhs.latestVersion != rhs.latestVersion {return false}
    if lhs.title != rhs.title {return false}
    if lhs.releaseSummary != rhs.releaseSummary {return false}
    if lhs.releaseURL != rhs.releaseURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateCommandRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateCommandRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularFixed32Field(value: self.key, fieldNumber: 1)
    }
    if self.command != .none {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateCommandRequest, rhs: UpdateCommandRequest) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
